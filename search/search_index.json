{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>markupy is a plain Python alternative to traditional templates engines for generating HTML code.</p> <p>Writing this code in Python with markupy...</p> <pre><code># Import \"tags\" like they were regular Python objects\nfrom markupy.tag import A, Body, Head, Html, Li, P, Title, Ul\n\nmenu = [(\"Home\", \"/\"), (\"About us\", \"/about\"), (\"Contact\", \"/contact\")]\nprint(\n    Html[\n        Head[Title[\"My website\"]],\n        Body[\n            P[\"Table of contents:\"],\n            Ul(\".menu\")[(Li[A(href=url)[title]] for title, url in menu)],\n        ],\n    ]\n)\n</code></pre> <p>...will generate this HTML:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My website&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Table of contents:&lt;/p&gt;\n    &lt;ul class=\"menu\"&gt;\n      &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"/about\"&gt;About us&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"/contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Seems interesting? Try it by yourself with our online html2markupy converter.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Like most Python web developers, we have relied on template engines (Jinja, Django, ...) since forever to generate HTML on the server side. Although this is fine for simple needs, when your site grows bigger, you might start facing some issues:</p> <ul> <li> <p>More an more Python code get put into unreadable and untestable macros</p> </li> <li> <p>Extends and includes make it very hard to track required parameters</p> </li> <li> <p>Templates are very permissive regarding typing making it more error prone</p> </li> </ul> <p>If this is you struggling with templates, then you should definitely give markupy a try!</p>"},{"location":"#inspiration","title":"Inspiration","text":"<p>markupy started as a fork of htpy. Even though the two projects are still conceptually very similar, we started markupy in order to support a slightly different syntax to optimize readability, reduce risk of conflicts with variables, and better support for non native html attributes syntax as python kwargs. On top of that, markupy provides a first class support for class based components.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Leverage static types: Use mypy or pyright to type check your code.</p> </li> <li> <p>Great debugging: Avoid cryptic stack traces from templates. Use your favorite Python debugger.</p> </li> <li> <p>Easy to extend: There is no special way to define template tags/filters. Just call regular functions.</p> </li> <li> <p>Works with existing Python web framework: Works great with Django, Flask or any other Python web framework!</p> </li> <li> <p>Works great with htmx: markupy makes for a great experience when writing server rendered partials/components.</p> </li> <li> <p>Create reusable components: Define components, snippets, complex layouts/pages as regular Python variables or functions.</p> </li> <li> <p>Familiar concepts from React: React helped make it popular writing HTML with a programming language. markupy uses a lot of similar constructs.</p> </li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>markupy generates HTML elements and attributes and provide a few helpers.</p> <p>markupy does not enforce any particular pattern or style to organize your pages, components and layouts. That does not mean that markupy cannot be used to build sophisticated web pages or applications.</p> <p>Rather the opposite: you are encouraged the leverage the power of Python to structure your project. Use modules, classes, functions, decorators, list comprehension, generators, conditionals, static typing and any other feature of Python to organize your components. This gives you a lot of power and makes markupy scale from a small one file project to bigger applications.</p>"},{"location":"#installation","title":"Installation","text":"<p>markupy is available on PyPI. You may install the latest version using pip:</p> <pre><code>pip install markupy\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The full documentation is available at markupy.witiz.com:</p> <ul> <li>Usage</li> <li>Components</li> <li>html2markupy</li> <li>Integrating with Flask</li> <li>Integrating with Starlette</li> <li>Integrating with Django</li> </ul>"},{"location":"components/","title":"Components","text":"<p>Although markupy intend to remain a generic library to allow you generate HTML, it also provides a powerful support for components in order to build reusable chunks of HTML.</p>"},{"location":"components/#create-reusable-fragments-with-components","title":"Create reusable fragments with components","text":""},{"location":"components/#building-your-first-component","title":"Building your first component","text":"<p>Let's start by creating a component that renders a Boostrap card.</p>"},{"location":"components/#components-as-functions","title":"Components as functions","text":"<p>Building a function component is a simple as returning elements from a regular python function:</p> <pre><code>def card_component(title:str, content:str) -&gt; View:\n    return Div(\".card\")[\n        Div(\".card-body\")[\n            H5(\".card-title\")[\n                title\n            ],\n            P(\".card-text\")[\n                content\n            ],\n        ]\n    ]\n</code></pre> <p>Note</p> <p>In the rest of the documentation, we will mostly focus on class based components that offer more flexibility with the ability to inherit each other but after all, it's also a matter of taste so feel free to experiment and find what works best for you.</p>"},{"location":"components/#components-as-classes","title":"Components as classes","text":"<p>Building a class component is done by subclassing the built-in <code>Component</code> abstract class and implementing the one required <code>render()</code> instance method that defines your component structure.</p> <pre><code>from markupy import Component, View\nfrom markupy.tag import Div, H5, P\n\nclass CardComponent(Component):\n    def render(self) -&gt; View:\n        return Div(\".card\")[\n            Div(\".card-body\")[\n                H5(\".card-title\")[\n                    \"Card title\"\n                ],\n                P(\".card-text\")[\n                    \"This is my card's content.\"\n                ],\n            ]\n        ]\n</code></pre> <p>And then to generate the actual HTML for this component, you just need to instantiate it and make it into a <code>str</code>:</p> <pre><code>&gt;&gt;&gt; str(CardComponent())\n</code></pre> <p>Note that the component <code>render()</code> method needs to return a <code>View</code>, which means it can be any of an <code>Element</code>, <code>Fragment</code> or another <code>Component</code>.</p> <p>See how this can save you from repeating a lot of code? But we're not there yet, because right now our card always has the same title and content. Time to keep improving our component.</p>"},{"location":"components/#pass-data-to-a-class-component-with-constructor","title":"Pass data to a class component with constructor","text":"<p>Let's make our card data dynamic by adding a constructor to our component. Let's say our card is in charge of displaying a <code>Post</code> object:</p> <pre><code>from markupy import Component, View\nfrom markupy.tag import Div, H5, P\nfrom my_models import Post\n\nclass PostCardComponent(Component):\n    def __init__(self, *, post: Post) -&gt; None:\n        super().__init__()\n        self.post = post\n\n    def render(self) -&gt; View:\n        return Div(\".card\")[\n            Div(\".card-body\")[\n                H5(\".card-title\")[\n                    self.post.title\n                ],\n                P(\".card-text\")[\n                    self.post.description\n                ],\n            ]\n        ]\n</code></pre>"},{"location":"components/#components-in-components","title":"Components in components","text":"<p>Usually, cards are displayed as part of a collection. Let's say we have a blog that is managing a list of posts, let's create a new component that would be in charge of displaying a list of cards:</p> <pre><code>from markupy import Component, View\nfrom markupy.tag import Div, H5, P\nfrom my_models import Post\n\nclass PostCardListComponent(Component):\n    def __init__(self, *, posts: list[Post]) -&gt; None:\n        super().__init__()\n        self.posts = posts\n\n    def render(self) -&gt; View:\n        return Div(\".card-group\")[\n            (PostCardComponent(post=post) for post in self.posts)\n        ]\n</code></pre> <p>And that's it, we are looping over a list of posts to generate card components that are added as children of another component. Displaying a list of posts as cards is now super easy:</p> <pre><code>&gt;&gt;&gt; str(PostCardListComponent(posts=my_posts))\n</code></pre>"},{"location":"components/#passing-children-to-components","title":"Passing children to components","text":"<p>Content can be assigned to component the same way we are doing for Fragments or Elements. To tell your component where such content needs to be injected when rendering, you need to call the <code>self.render_content()</code> reserved method:</p> <pre><code>from markupy import Component, tag\n\nclass Title(Component):\n    def __init__(self, id: str) -&gt; None:\n        super().__init__()\n        self.id = id\n\n    def render(self) -&gt; View:\n        return tag.H1(\".title.header\", id=self.id)[self.render_content()]\n</code></pre> <p>Then to use this component:</p> <pre><code>&gt;&gt;&gt; str(Title(id=\"headline\")[\"hello \", tag.I(\".star.icon\")])\n</code></pre> <p>This will render as:</p> <pre><code>&lt;h1 class=\"title header\" id=\"headline\"&gt;\n    hello &lt;i class=\"star icon\"&gt;&lt;/i&gt;\n&lt;/h1&gt;\n</code></pre>"},{"location":"components/#using-components-to-define-layouts","title":"Using components to define layouts","text":"<p>Another very interesting use for components is to define your pages layouts.</p>"},{"location":"components/#implementing-a-basic-layout","title":"Implementing a basic layout","text":"<p>Below is a very basic layout that specifies a default head and body, with some placeholders that we can implement when inheriting this layout.</p> <pre><code>from markupy import Component, View\nfrom markupy.tag import H1, Body, Footer, Head, Header, Html, Main, Title\n\nclass BaseLayout(Component):\n    def render_title(self) -&gt; str:\n        return \"My website\"\n\n    def render_main(self) -&gt; View:\n        return None\n\n    def render(self) -&gt; View:\n        return Html[\n            Head[\n                Title[self.render_title()],\n            ],\n            Body[\n                Header(\".container\")[H1[\"Welcome!\"]],\n                Main(\".container\")[self.render_main()],\n                Footer(\".container\")[\"\u00a9 My Company\"],\n            ],\n        ]\n</code></pre> <p>Note</p> <p>Here we defined the placeholders as instance methods called render_*. This is just a convention and nothing is enforced in naming them.</p>"},{"location":"components/#extending-a-layout-to-implement-a-page","title":"Extending a layout to implement a page","text":"<p>Then when we need to define a specific page, we need to subclass the layout an override the needed placeholders:</p> <pre><code>from markupy import Fragment, View\nfrom markupy.tag import H2\nfrom my_components import PostCardListComponent\nfrom my_models import Post\n\nclass BlogPage(BaseLayout):\n    def __init__(self, *, posts:list[Post]) -&gt; None:\n        super().__init__()\n        self.posts = posts\n\n    def render_title(self) -&gt; str:\n        return f\"Blog | {super().render_title()}\"\n\n    def render_main(self) -&gt; View:\n        return Fragment[\n            H2[\"Blog posts\"],\n            PostCardListComponent(posts=self.posts)\n        ]\n</code></pre> <p>Note</p> <p>Notice in the <code>render_title</code> how we can only partially replace the content from the inherited layout (here we are preprending the default page title with the <code>Blog |</code> value.)</p> <p>As usual, generating HTML for the page is just a matter of instanciating and converting to <code>str</code>:</p> <pre><code>&gt;&gt;&gt; str(BlogPage(posts=my_posts))\n</code></pre>"},{"location":"django/","title":"Integrating with Django","text":""},{"location":"django/#returning-a-markupy-response","title":"Returning a markupy Response","text":"<p>markupy elements can be passed directly to <code>HttpResponse</code>:</p> views.py<pre><code>from django.http import HttpResponse\nfrom markupy.tag import H1\n\ndef my_view(request):\n    return HttpResponse(H1[\"Hi Django!\"])\n</code></pre>"},{"location":"django/#using-markupy-as-part-of-an-existing-django-template","title":"Using markupy as part of an existing Django template","text":"<p>markupy elements are marked as \"safe\" and can be injected directly into Django templates. This can be useful if you want to start using markupy gradually in an existing template based Django project:</p> base.html<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;My Django Site&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        {{ content }}\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> views.py<pre><code>from django.shortcuts import render\n\nfrom markupy.tag import H1\n\n\ndef index(request):\n    return render(request, \"base.html\", {\n        \"content\": H1[\"Welcome to my site!\"],\n    })\n</code></pre>"},{"location":"django/#render-a-django-form","title":"Render a Django Form","text":"<p>CSRF token, form widgets and errors can be directly used within markupy elements:</p> forms.py<pre><code>from django import forms\n\n\nclass MyForm(forms.Form):\n    name = forms.CharField()\n</code></pre> views.py<pre><code>from django.http import HttpRequest, HttpResponse\n\nfrom .components import my_form_page, my_form_success_page\nfrom .forms import MyForm\n\n\ndef my_form(request: HttpRequest) -&gt; HttpResponse:\n    form = MyForm(request.POST or None)\n    if form.is_valid():\n        return HttpResponse(my_form_success_page())\n\n    return HttpResponse(my_form_page(request, my_form=form))\n</code></pre> components.py<pre><code>from django.http import HttpRequest\nfrom django.template.backends.utils import csrf_input\n\nfrom markupy import View\nfrom markupy.tag import Body, Button, Form, H1, Head, Html, Title\n\nfrom .forms import MyForm\n\n\ndef base_page(title: str, content: View) -&gt; View:\n    return Html[\n        Head[Title[title]],\n        Body[content],\n    ]\n\n\ndef my_form_page(request: HttpRequest, *, form: MyForm) -&gt; View:\n    return base_page(\n        \"My form\",\n        form(method=\"post\")[\n            csrf_input(request),\n            form.errors,\n            form[\"name\"],\n            Button[\"Submit!\"],\n        ],\n    )\n\n\ndef my_form_success_page() -&gt; View:\n    return base_page(\n        \"Success!\",\n        H1[\"Success! The form was valid!\"],\n    )\n</code></pre>"},{"location":"django/#implement-custom-form-widgets-with-markupy","title":"Implement Custom Form Widgets With markupy","text":"<p>You can implement a custom form widget directly with markupy like this:</p> widgets.py<pre><code>from django.forms import widgets\n\nfrom markupy.tag import SlInput\n\n\nclass ShoelaceInput(widgets.Widget):\n    \"\"\"\n    A form widget using Shoelace's &lt;sl-input&gt; element.\n    More info: https://shoelace.style/components/input\n    \"\"\"\n\n    def render(self, name, value, attrs=None, renderer=None):\n        return str(SlInput(attrs, name=name, value=value))\n</code></pre>"},{"location":"flask/","title":"Integrating with Flask","text":""},{"location":"flask/#basic-integration","title":"Basic integration","text":"<p>Rendering markupy elements or components in flask is as easy as return a stringified instance from your routes.</p> <pre><code>from flask import Flask\nfrom markupy import Component, View\nfrom markupy.tag import H1\n\napp = Flask(__name__)\n\n@app.route(\"/page\")\ndef page():\n    return str(H1[\"Page with element\"])\n\nclass MyComponent(Component):\n    def render(self) -&gt; View:\n        return H1[\"Page with component\"]\n\n@app.route(\"/component\")\ndef component():\n    return str(MyComponent())\n</code></pre>"},{"location":"flask/#avoid-casting-to-str-by-subclassing-flask","title":"Avoid casting to str by subclassing Flask","text":"<p>As you saw previously, since Flask doesn't know about our elements or components, we need to convert them to <code>str</code> before returning them.</p> <p>You can avoid that by subclassing <code>Flask</code> and overriding the <code>make_response</code> method:</p> <pre><code>from flask import Flask\nfrom markupy import View\n\nclass MarkupyFlask(Flask):\n    # Here we override make_response to be able to return View instances\n    # from our routes directly without having to cast them to str()\n    def make_response(self, rv):\n        if isinstance(rv, View):\n            rv = str(rv)\n        return super().make_response(rv)\n</code></pre> <p>Note</p> <p>Here we check if our object to be rendered is a subclass of <code>markupy.View</code>, which is the base class for all markupy <code>Element</code>, <code>Fragment</code> and <code>Component</code>.</p> <p>And then our previous example becomes like this (basically we instantiate MarkupyFlask instead of Flask previously and do not need the calls to <code>str</code> anymore):</p> <pre><code>from my_flask import MarkupyFlask\nfrom markupy import Component, View\nfrom markupy.tag import H1\n\napp = MarkupyFlask(__name__)\n\n@app.route(\"/page\")\ndef page():\n    return H1[\"Hello!\"]\n\nclass MyComponent(Component):\n    def render(self) -&gt; View:\n        return H1[\"Hello!\"]\n\n@app.route(\"/component\")\ndef component():\n    return MyComponent()\n</code></pre>"},{"location":"flask/#streaming-html","title":"Streaming HTML","text":"<p>Given that markupy elements and components are iterables, you can leverage the power of python generators to stream the response instead of sending it all at once.</p> <p>Flask supports streaming out of the box (see docs).</p> <p>Note</p> <p>The examples below are returning very small and simple content, please be aware that you will only benefit from streaming for large contents.</p>"},{"location":"flask/#streaming-by-returning-a-generator","title":"Streaming by returning a generator","text":"<pre><code>from flask import Flask, stream_with_context\nfrom markupy import Component, View\nfrom markupy.tag import H1\n\napp = Flask(__name__)\n\n@app.route(\"/page\")\ndef page():\n    my_element = H1[\"Streaming element\"]\n    return stream_with_context(chunk for chunk in my_element)\n\nclass MyComponent(Component):\n    def render(self) -&gt; View:\n        return H1[\"Streaming component\"]\n\n@app.route(\"/component\")\ndef component():\n    return stream_with_context(chunk for chunk in MyComponent())\n</code></pre>"},{"location":"flask/#streaming-by-subclassing-flask","title":"Streaming by subclassing Flask","text":"<p>Same as above, if you prefer a cleaner syntax that will apply streaming to all your routes, we can adapt our <code>Flask</code> subclass:</p> <pre><code>from flask import Flask, stream_with_context\nfrom markupy import View\n\nclass MarkupyStreamFlask(Flask):\n    # Here we override make_response to be able to stream View instances\n    # from our routes directly when returning them\n    def make_response(self, rv):\n        if isinstance(rv, View):\n            rv = stream_with_context(chunk for chunk in rv)\n        return super().make_response(rv)\n</code></pre> <p>And then in your routes:</p> <pre><code>@app.route(\"/page\")\ndef page():\n    return H1[\"Hello!\"]\n</code></pre>"},{"location":"flask/#streaming-with-route-decorators","title":"Streaming with route decorators","text":"<p>If you prefer to apply this change on a route per route basis, you could also create a decorator that will take care of the component to stream conversion:</p> <pre><code>from functools import wraps\nfrom flask import stream_with_context\nfrom markupy import View\n\ndef markupy_stream(f):\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        rv = f(*args, **kwargs)\n        if isinstance(rv, View):\n            return stream_with_context(chunk for chunk in rv)\n        return rv\n\n    return wrapper\n</code></pre> <p>And then in your routes:</p> <pre><code>@app.route(\"/page\")\n@markupy_stream\ndef page():\n    return H1[\"Hello!\"]\n</code></pre>"},{"location":"html2markupy/","title":"Converting HTML to markupy","text":"<p>Maybe you already have a bunch of HTML, or templates that you would like to migrate to markupy. We got you covered in multiple ways.</p>"},{"location":"html2markupy/#converting-online-with-the-html2markupy-website","title":"Converting online with the html2markupy website","text":"<p>The simplest way to experiment with markupy and convert your HTML snippets is to use the online html2markupy converter.</p> <p>The app is powered by markupy itself so you will get the exact same result as the one provided by the below method.</p>"},{"location":"html2markupy/#converting-locally-with-the-built-in-html2markupy-command","title":"Converting locally with the built-in html2markupy command","text":"<p>The utility command <code>html2markupy</code> ships with <code>markupy</code>, and can be used to transform existing html into Python code (markupy!).</p> <pre><code>$ html2markupy -h\nusage: html2markupy [-h] [--selector | --no-selector] [--dict-attrs | --no-dict-attrs] [--tag-prefix | --no-tag-prefix] [input]\n\npositional arguments:\n  input                 input HTML from file or stdin\n\noptions:\n  -h, --help            show this help message and exit\n  --selector, --no-selector\n                        Use the selector #id.class syntax instead of explicit `id` and `class_` attributes (default: True)\n  --dict-attrs, --no-dict-attrs\n                        Prefer dict attributes (default: False)\n  --tag-prefix, --no-tag-prefix\n                        Output mode for imports of markupy elements (default: False)\n</code></pre> <p>Lets say you have an existing HTML file:</p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;title&gt;html2markupy&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;h1 class=\"heading\"&gt;Welcome to html2markupy!&lt;/h1&gt;\n    &lt;/header&gt;\n    &lt;main id=\"container\"&gt;\n        Discover a powerful way to build your HTML pages and components in Python!\n    &lt;/main&gt;\n    &lt;footer&gt;\n        Powered by &lt;a href=\"https://markupy.witiz.com\"&gt;markupy&lt;/a&gt;\n    &lt;/footer&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now, if you run the command, it outputs the corresponding Python code (markupy).</p> <pre><code>$ html2markupy index.html\n</code></pre> <pre><code>from markupy.tag import A,Body,Footer,H1,Head,Header,Html,Main,Title\nHtml(lang=\"en\")[Head[Title[\"html2markupy\"]],Body[Header[H1(\".heading\")[\"Welcome to html2markupy!\"]],Main(\"#container\")[\"Discover a powerful way to build your HTML pages and components in Python!\"],Footer[\"Powered by\",A(href=\"https://markupy.witiz.com\")[\"markupy\"]]]]\n</code></pre>"},{"location":"html2markupy/#piping-inputstdin-stream","title":"Piping Input/Stdin Stream","text":"<p>You can also pipe input to markupy:</p> <pre><code>$ cat index.html | html2markupy\n</code></pre> <p>This can be combined with other workflows in the way that you find most suitable. For example, you might pipe from your clipboard to markupy, and optionally direct the output to a file.</p>"},{"location":"html2markupy/#formatting-the-output","title":"Formatting the Output","text":"<p><code>html2markupy</code> is by default providing an unformatted output, but you can easily combine it with your preferred formatter (must be installed separately). Below is an example formatting with ruff:</p> <pre><code>$ html2markupy index.html | ruff format - \n</code></pre>"},{"location":"html2markupy/#command-options","title":"Command Options","text":"<p>Say you have the following HTML snippet.</p> example.html<pre><code>&lt;section id=\"main-section\" class=\"container\"&gt;\n  &lt;a class=\"btn btn-primary\" href=\"/index\"&gt;Home&lt;/a&gt;\n&lt;/section&gt;\n</code></pre> <p>You can adapt the markupy conversion with a couple of options.</p>"},{"location":"html2markupy/#imports-management","title":"Imports management","text":"<p>Some people prefer to <code>import markupy as tag</code> instead of importing individual elements <code>from markupy.tag</code>. If this is you, you can use the <code>--tag-prefix</code> option to get corresponding output when using <code>html2markupy</code>.</p> --no-tag-prefix (default)--tag-prefix <pre><code>from markupy.tag import A, Section\n\nSection(\"#main-section.container\")[\n    A(\".btn.btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre> <pre><code>from markupy import tag\n\ntag.Section(\"#main-section.container\")[\n    tag.A(\".btn.btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre>"},{"location":"html2markupy/#explicit-id-and-class-kwargs","title":"Explicit <code>id</code> and <code>class</code> kwargs","text":"<p>If you prefer the explicit <code>id=\"id\", class_=\"class\"</code> kwargs syntax over the default markupy shorthand <code>#id.class</code> syntax, you can get it by passing the <code>--no-selector</code> flag.</p> --selector (default)--no-selector <pre><code>from markupy.tag import A, Section\n\nSection(\"#main-section.container\")[\n    A(\".btn.btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre> <pre><code>from markupy.tag import A, Section\n\nSection(id=\"main-section\" class_=\"container\")[\n    A(class_=\"btn btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre>"},{"location":"html2markupy/#attributes-as-dict-vs-arguments","title":"Attributes as dict vs arguments","text":"<p>The <code>--dict-args</code> flag lets you declare attributes as a dictionary instead of the default python arguments.</p> --no-dict-args (default)--dict-args <pre><code>from markupy.tag import A, Section\n\nSection(\"#main-section.container\")[\n    A(\".btn.btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre> <pre><code>from markupy.tag import A, Section\n\nSection(\"#main-section.container\")[\n    A(\".btn.btn-primary\", {\"href\": \"/index\"})[\"Home\"]\n]\n</code></pre>"},{"location":"starlette/","title":"Integrating with Starlette","text":"<p>markupy can be used with Starlette to generate HTML. Since FastAPI is built upon Starlette, markupy can also be used with FastAPI.</p> <p>To return HTML contents, pass a markupy element to Starlette's <code>HTMLResponse</code>:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse\nfrom starlette.routing import Route\n\nfrom markupy.tag import H1\n\n\nasync def index(request: Request) -&gt; HTMLResponse:\n    return HTMLResponse(H1[\"Hi Starlette!\"])\n\n\napp = Starlette(routes=[Route(\"/\", index)])\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#elements","title":"Elements","text":"<p>HTML elements are imported directly from the <code>markupy.tag</code> module as their name using the CapitalizedCase syntax. Although HTML elements are usually spelled in lower case, using CapitalizedCase in markupy avoids naming conflicts with your own variables and makes it easier to distinguish markupy tags vs other parts of your code.</p> Importing elements<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div)\n&lt;div&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#attributes","title":"Attributes","text":"<p>HTML attributes are specified by using parenthesis <code>()</code> syntax on an element.</p> Element attributes<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div(id=\"container\", style=\"color:red\"))\n&lt;div id=\"container\" style=\"color:red\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#children","title":"Children","text":"<p>Children are specified using square brackets <code>[]</code> syntax on an element. Children can be strings, ints, markup, other elements or lists/iterators.</p> <p>Elements can be arbitrarily nested:</p> Nested elements<pre><code>&gt;&gt;&gt; from markupy.tag import Article, Section, P\n&gt;&gt;&gt; print(Section[Article[P[\"Lorem ipsum\"]]])\n&lt;section&gt;&lt;article&gt;&lt;p&gt;Lorem ipsum&lt;/p&gt;&lt;/article&gt;&lt;/section&gt;\n</code></pre> <p>Don't forget to close your tags</p> <p>Another main advantage of the markupy syntax over raw HTML is that you don't have to repeat the tag name to close an element. Of course you still need to close your tags with a closing bracket <code>]</code> but this is much more straightforward and your IDE should help you matching/indenting them fairly easily.</p>"},{"location":"usage/#textstrings","title":"Text/Strings","text":"<p>It is possible to pass a string directly as an element's child:</p> Using a string as children<pre><code>&gt;&gt;&gt; from markupy.tag import H1\n&gt;&gt;&gt; print(H1[\"Welcome to my site!\"])\n&lt;h1&gt;Welcome to my site!&lt;/h1&gt;\n</code></pre> <p>Strings are automatically escaped to avoid XSS vulnerabilities. It is convenient and safe to directly insert variable data via f-strings:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import H1\n&gt;&gt;&gt; user_supplied_name = \"bobby &lt;/h1&gt;\"\n&gt;&gt;&gt; print(H1[f\"hello {user_supplied_name}\"])\n&lt;h1&gt;hello bobby &amp;lt;/h1&amp;gt;&lt;/h1&gt;\n</code></pre> <p>An exception for <code>script</code> and <code>style</code> tags</p> <p>Script and style tags are special because they usually expect their content to be respectively javascript and css code. In order for code to work properly, <code>Script</code> and <code>Style</code> child nodes will not be automatically escaped. Keep in mind that you will need to escape sensitive values yourself inside these 2 tags. </p>"},{"location":"usage/#injecting-markup","title":"Injecting Markup","text":"<p>If you have HTML markup that you want to insert without further escaping, wrap it in <code>Markup</code> from the markupsafe library. markupsafe is a dependency of markupy and is automatically installed:</p> Injecting markup<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; print(Div[Markup(\"&lt;foo&gt;&lt;/foo&gt;\")])\n&lt;div&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/div&gt;\n</code></pre> <p>If you are generate Markdown and want to insert it into an element, use <code>Markup</code>:</p> Injecting generated markdown<pre><code>&gt;&gt;&gt; from markdown import markdown\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div[Markup(markdown('# Hi'))])\n&lt;div&gt;&lt;h1&gt;Hi&lt;/h1&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#conditional-rendering","title":"Conditional Rendering","text":"<p>Children that evaluate to <code>True</code>, <code>False</code> and <code>None</code> will not be rendered. Python's <code>and</code> and <code>or</code> operators will short-circuit. You can use this to conditionally render content with inline <code>and</code> and <code>or</code>.</p> Conditional rendering with a value that may be None<pre><code>&gt;&gt;&gt; from markupy.tag import Div, Strong\n\n# No &lt;strong&gt; tag will be rendered since error is None\n&gt;&gt;&gt; error = None\n&gt;&gt;&gt; print(Div[error and Strong[error]])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; error = \"Email address is invalid.\"\n&gt;&gt;&gt; print(Div[error and Strong[error]])\n&lt;div&gt;&lt;strong&gt;Email address is invalid.&lt;/strong&gt;&lt;/div&gt;\n\n# Inline if/else can also be used:\n&gt;&gt;&gt; print(Div[Strong[error] if error else None])\n&lt;div&gt;&lt;strong&gt;Email address is invalid.&lt;/strong&gt;&lt;/div&gt;\n</code></pre> Conditional rendering based on a bool variable<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n\n&gt;&gt;&gt; is_allowed = True\n&gt;&gt;&gt; print(Div[is_allowed and \"Access granted!\"])\n&lt;div&gt;Access granted!&lt;/div&gt;\n&gt;&gt;&gt; print(Div[is_allowed or \"Access denied!\"])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; is_allowed = False\n&gt;&gt;&gt; print(Div[is_allowed and \"Access granted!\"])\n&lt;div&gt;&lt;/div&gt;\n&gt;&gt;&gt; print(Div[is_allowed or \"Access denied!\"])\n&lt;div&gt;Access denied&lt;/div&gt;\n</code></pre>"},{"location":"usage/#fragments","title":"Fragments","text":"<p>Fragments allow you to wrap a group of nodes (not necessarily elements) so that they can be rendered without a wrapping element.</p> <pre><code>&gt;&gt;&gt; from markupy.tag import P, I, Fragment\n&gt;&gt;&gt; content = Fragment[\"Hello \", None, I[\"world!\"]]\n&gt;&gt;&gt; print(content)\nHello &lt;i&gt;world!&lt;/i&gt;\n\n&gt;&gt;&gt; print(P[content])\n&lt;p&gt;Hello &lt;i&gt;world!&lt;/i&gt;&lt;/p&gt;\n</code></pre>"},{"location":"usage/#loops-iterating-over-children","title":"Loops / Iterating Over Children","text":"<p>You can pass a list, tuple or generator to generate multiple children:</p> Iterate over a generator<pre><code>&gt;&gt;&gt; from markupy.tag import Ul, Li\n&gt;&gt;&gt; print(Ul[(Li[letter] for letter in \"abc\")])\n&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;\n</code></pre> <p>Note</p> <p>The generator will be lazily evaluated when rendering the element, not directly when the element is constructed.</p> <p>A <code>list</code> can be used similar to a JSX fragment:</p> Render a list of child elements<pre><code>&gt;&gt;&gt; from markupy.tag import Div, Img\n&gt;&gt;&gt; my_images = [Img(src=\"a.jpg\"), Img(src=\"b.jpg\")]\n&gt;&gt;&gt; print(Div[my_images])\n&lt;div&gt;&lt;img src=\"a.jpg\"&gt;&lt;img src=\"b.jpg\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#custom-elements-web-components","title":"Custom Elements / Web Components","text":"<p>Custom elements / web components are HTML elements that contains at least one dash (<code>-</code>). Since <code>-</code> cannot be used in Python identifiers, here's how you'd write them in markupy:</p> Custom elements with CapitalizedCase syntax<pre><code>&gt;&gt;&gt; from markupy.tag import MyCustomElement\n&gt;&gt;&gt; print(MyCustomElement['hi!'])\n&lt;my-custom-element&gt;hi!&lt;/my-custom-element&gt;\n</code></pre>"},{"location":"usage/#html-doctype","title":"HTML Doctype","text":"<p>The HTML5 doctype is automatically prepended to the <code>&lt;html&gt;</code> tag:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Html\n&gt;&gt;&gt; print(Html)\n&lt;!doctype html&gt;&lt;html&gt;&lt;/html&gt;\n</code></pre>"},{"location":"usage/#html-comments","title":"HTML Comments","text":"<p>Since the Python code is the source of the HTML generation, to add a comment to the code, most of the time regular Python comments (<code>#</code>) are used.</p> <p>If you want to emit HTML comments that will be visible in the browser, you need to initialize a special element whose name is <code>_</code>:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Div, _\n&gt;&gt;&gt; print(Div[_[\"This is a HTML comment\"]])\n&lt;div&gt;&lt;!--This is a HTML comment--&gt;&lt;/div&gt;\n</code></pre> <p>Given that a comment is a <code>Element</code>, you can wrap other elements as children:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Div, Strong, _\n&gt;&gt;&gt; print(Div[_[\"This is a HTML comment\", Strong[\"Hidden text\"]]])\n&lt;div&gt;&lt;!--This is a HTML comment&lt;strong&gt;Hidden text&lt;/strong&gt;--&gt;&lt;/div&gt;\n</code></pre> <p>If you need full control over the exact rendering of the comment, you can create comments or arbitrary text by injecting your own markup. See the Injecting Markup section above for details.</p>"},{"location":"usage/#attributes_1","title":"Attributes","text":"<p>HTML attributes are defined by calling the element. They can be specified in a couple of different ways.</p>"},{"location":"usage/#elements-without-attributes","title":"Elements Without Attributes","text":"<p>For elements that do not have attributes, they can be specified by just the element itself:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Hr\n&gt;&gt;&gt; print(Hr)\n&lt;hr&gt;\n</code></pre>"},{"location":"usage/#keyword-arguments","title":"Keyword Arguments","text":"<p>Attributes can be specified via keyword arguments:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Img\n&gt;&gt;&gt; print(Img(src=\"picture.jpg\"))\n&lt;img src=\"picture.jpg\"&gt;\n</code></pre> <p>In Python, some names such as <code>class</code> and <code>for</code> are reserved and cannot be used as keyword arguments. Instead, they can be specified as <code>class_</code> or <code>for_</code> when using keyword arguments:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Label\n&gt;&gt;&gt; print(Label(for_=\"myfield\"))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre> <p>Attributes that contains dashes <code>-</code> can be specified using mixedCase syntax:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Form\n&gt;&gt;&gt; print(Form(hxPost=\"/foo\"))\n&lt;form hx-post=\"/foo\"&gt;&lt;/form&gt;\n</code></pre> <p>But what about PEP8 ?!</p> <p>Some might argue that using mixedCase for attribute names is not Pythonic. It is not indeed. It's a tradeoff we are doing given the low number of chars available to build valid identifiers in Python and the broad diversity of possible chars that can be used as HTML attributes. Just keep in mind anyway that the vast majority of HTML attributes are single worded lower case.</p> <p>markupy also allows you to write more complex HTML attributes by using the following conventions:</p> HTML attribute markupy attribute HTML to markupy conversion <code>class=\"...\"</code> <code>class_=\"...\"</code> trailing underscore <code>_</code> is meaningless <code>data-value=\"...\"</code> <code>dataValue=\"...\"</code> <code>kebab-case</code> \u279c <code>mixedCase</code> <code>v-on:click=\"...\"</code> <code>vOn__click=\"...\"</code> colon <code>:</code> \u279c double underscore <code>__</code> <code>@click=\"...\"</code> <code>_click=\"...\"</code> leading at <code>@</code> \u279c leading underscore <code>_</code> <code>@click.outside=\"...\"</code> <code>_click_outside=\"...\"</code> dot <code>.</code> \u279c underscore <code>_</code> <p>Combining all those rules together, you can basically write as python identifiers 95% of HTML attributes used in modern frontend frameworks and libraries such as htmx, Alpine.js or Vue.js</p>"},{"location":"usage/#idclass-selector-shorthand","title":"Id/Class selector shorthand","text":"<p>Defining <code>id</code> and <code>class</code> attributes is common when writing HTML. A string shorthand that looks like a CSS selector can be used to quickly define id and classes:</p> Define id<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div(\"#myid\"))\n&lt;div id=\"myid\"&gt;&lt;/div&gt;\n</code></pre> Define multiple classes<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div(\".foo.bar\"))\n&lt;div class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre> Combining both id and classes<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div(\"#myid.foo.bar\"))\n&lt;div id=\"myid\" class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre> <p>Selector string format</p> <p>The selector string should begin with the <code>#id</code> if present, then followed by <code>.classes</code> definition.</p>"},{"location":"usage/#attributes-as-dict","title":"Attributes as Dict","text":"<p>Attributes can also be specified as a <code>dict</code>. This is useful when using attributes that are reserved Python keywords (like <code>for</code> or <code>class</code>), when the attribute name contains special characters or when you want to define attributes dynamically.</p> Using Alpine.js with @-syntax (shorthand for x-on)<pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; print(Button({\"@click.shift\": \"addToSelection()\"}))\n&lt;button @click.shift=\"addToSelection()\"&gt;&lt;/button&gt;\n</code></pre> Using an attribute with a reserved keyword<pre><code>&gt;&gt;&gt; from markupy.tag import Label\n&gt;&gt;&gt; print(Label({\"for\": \"myfield\"}))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre>"},{"location":"usage/#booleanempty-attributes","title":"Boolean/Empty Attributes","text":"<p>In HTML, boolean attributes such as <code>disabled</code> are considered \"true\" when they exist. Specifying an attribute as <code>True</code> will make it appear (without a value). <code>False</code> will make it hidden. This is useful and brings the semantics of <code>bool</code> to HTML.</p> True bool attribute<pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; print(Button(disabled=True))\n&lt;button disabled&gt;&lt;/button&gt;\n</code></pre> False bool attribute<pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; print(Button(disabled=False))\n&lt;button&gt;&lt;/button&gt;\n</code></pre>"},{"location":"usage/#conditionally-mixing-css-classes","title":"Conditionally Mixing CSS Classes","text":"<p>To make it easier to mix CSS classes, the <code>class</code> attribute accepts a list of class names or a dict. Falsey values will be ignored.</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; is_primary = True\n&gt;&gt;&gt; print(Button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn btn-primary\"&gt;&lt;/button&gt;\n&gt;&gt;&gt; is_primary = False\n&gt;&gt;&gt; print(Button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn\"&gt;&lt;/button&gt;\n&gt;&gt;&gt;\n</code></pre>"},{"location":"usage/#combining-modes","title":"Combining Modes","text":"<p>Attributes via id/class shorthand, keyword arguments and dictionary can be combined:</p> Specifying attribute via multiple arguments<pre><code>&gt;&gt;&gt; from markupy.tag import Label\n&gt;&gt;&gt; print(Label(\"#myid.foo.bar\", {\"for\": \"somefield\"}, name=\"myname\",))\n&lt;label id=\"myid\" class=\"foo bar\" for=\"somefield\" name=\"myname\"&gt;&lt;/label&gt;\n</code></pre> <p>Order is important</p> <p>When combining multiple attribute definition methods, it's important to respect the order between them: first should come the selector id/class string, then dictionary of attributes and finally keyword attributes.</p>"},{"location":"usage/#escaping-of-attributes","title":"Escaping of Attributes","text":"<p>Attributes are always escaped. This makes it possible to pass arbitrary HTML fragments or scripts as attributes. The output may look a bit obfuscated since all unsafe characters are escaped but the browser will interpret it correctly:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; print(Button(id=\"example\", onclick=\"let name = 'bob'; alert('hi' + name);\")[\"Say hi\"])\n&lt;button onclick=\"let name = &amp;#39;bob&amp;#39;; alert(&amp;#39;hi&amp;#39; + name);\"&gt;Say hi&lt;/button&gt;\n</code></pre> <p>In the browser, the parsed attribute as returned by <code>document.getElementById(\"example\").getAttribute(\"onclick\")</code> will be the original string <code>let name = 'bob'; alert('hi' + name);</code>.</p> <p>Escaping will happen whether or not the value is wrapped in <code>markupsafe.Markup</code> or not. This may seem confusing at first but is useful when embedding HTML snippets as attributes:</p> Escaping of Markup<pre><code>&gt;&gt;&gt; from markupy.tag import Ul\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; # This markup may come from another library/template engine\n&gt;&gt;&gt; some_markup = Markup(\"\"\"&lt;li class=\"bar\"&gt;&lt;/li&gt;\"\"\")\n&gt;&gt;&gt; print(Ul(dataTemplate=some_markup))\n&lt;ul data-template=\"&amp;lt;li class=&amp;#34;bar&amp;#34;&amp;gt;&amp;lt;/li&amp;gt;\"&gt;&lt;/ul&gt;\n</code></pre>"},{"location":"usage/#iterating-of-the-output","title":"Iterating of the Output","text":"<p>Iterating over a markupy element will yield the resulting contents in chunks as they are rendered:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Ul, Li\n&gt;&gt;&gt; for chunk in Ul[Li[\"a\"], Li[\"b\"]]:\n...     print(f\"got a chunk: {chunk!r}\")\n...\ngot a chunk: '&lt;ul&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'a'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'b'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;/ul&gt;'\n</code></pre> <p>Note</p> <p>This feature can be leveraged to stream HTML contents by returning a generator instead of a fully generated str. How to integrate this is heavily depending on which framework you are using to power your website.</p>"}]}
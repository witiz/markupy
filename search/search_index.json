{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#markupy-html-in-python","title":"markupy - HTML in Python","text":"<p>markupy is a plain Python alternative to traditional templates engines for generating HTML code.</p> <p>Writing this code in Python with markupy...</p> <pre><code># Import \"tags\" like they were regular Python objects\nfrom markupy.tag import A, Body, Head, Html, Li, P, Title, Ul\n\nmenu = [(\"Home\", \"/\"), (\"About us\", \"/about\"), (\"Contact\", \"/contact\")]\nprint(\n    Html[\n        Head[Title[\"My website\"]],\n        Body[\n            P[\"Table of contents:\"],\n            Ul(\".menu\")[(Li[A(href=url)[title]] for title, url in menu)],\n        ],\n    ]\n)\n</code></pre> <p>...will generate this HTML:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My website&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Table of contents:&lt;/p&gt;\n    &lt;ul class=\"menu\"&gt;\n      &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"/about\"&gt;About us&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"/contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"#motivation","title":"Motivation","text":"<p>Like most Python web developers, we have relied on template engines (Jinja, Django, ...) since forever to generate HTML on the server side. Although this is fine for simple needs, when your site grows bigger, you might start facing some issues:</p> <ul> <li> <p>More an more Python code get put into unreadable and untestable macros</p> </li> <li> <p>Extends and includes make it very hard to track required parameters</p> </li> <li> <p>Templates are very permissive regarding typing making it more error prone</p> </li> </ul> <p>If this is you struggling with templates, then you should definitely give markupy a try!</p>"},{"location":"#inspiration","title":"Inspiration","text":"<p>markupy started as a fork of htpy. Even though the two projects are still conceptually very similar, we started markupy in order to support a slightly different syntax to optimize readability, reduce risk of conflicts with variables, and better support for non native html attributes syntax as python kwargs.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Leverage static types: Use mypy or pyright to type check your code.</p> </li> <li> <p>Great debugging: Avoid cryptic stack traces from templates. Use your favorite Python debugger.</p> </li> <li> <p>Easy to extend: There is no special way to define template tags/filters. Just call regular functions.</p> </li> <li> <p>Works with existing Python web framework: Works great with Django, Flask or any other Python web framework!</p> </li> <li> <p>Works great with htmx: markupy makes for a great experience when writing server rendered partials/components.</p> </li> <li> <p>Create reusable components: Define components, snippets, complex layouts/pages as regular Python variables or functions.</p> </li> <li> <p>Familiar concepts from React: React helped make it popular writing HTML with a programming language. markupy uses a lot of similar constructs.</p> </li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>markupy generates HTML elements and attributes and provide a few helpers.</p> <p>markupy does not enforce any particular pattern or style to organize your pages, components and layouts. That does not mean that markupy cannot be used to build sophisticated web pages or applications.</p> <p>Rather the opposite: you are encouraged the leverage the power of Python to structure your project. Use modules, classes, functions, decorators, list comprehension, generators, conditionals, static typing and any other feature of Python to organize your components. This gives you a lot of power and makes markupy scale from a single small Flask project to bigger applications.</p>"},{"location":"#installation","title":"Installation","text":"<p>markupy is available on PyPI. You may install the latest version using pip:</p> <pre><code>pip install markupy\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The full documentation is available at markupy.witiz.com:</p> <ul> <li>Usage</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#elements","title":"Elements","text":"<p>All elements in markupy are objects derived from the <code>Element</code> class. Elements are imported directly from the <code>markupy</code> module as their name using one of the 2 following syntaxes:</p> <ul> <li>CapitalizedCase : this is the recommended syntax as it avoids naming conflicts between markupy elements and your own variables and makes it easier to distinguish markupy / HTML tags vs other parts of your code.</li> <li>snake_case : this is mostly provided to make it easier for users transitioning from other libraries or to support personal preference.</li> </ul> <p>HTML attributes are specified by using parenthesis <code>()</code> syntax on an element.</p> CapitalizedCasesnake_case <pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div(id=\"hi\")[\"Hello!\"])\n&lt;div id=\"hi\"&gt;Hello!&lt;/div&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; from markupy.tag import div\n&gt;&gt;&gt; print(div(id=\"hi\")[\"Hello!\"])\n&lt;div id=\"hi\"&gt;Hello!&lt;/div&gt;\n</code></pre>"},{"location":"usage/#children","title":"Children","text":"<p>Children are specified using square brackets <code>[]</code> syntax on an element. Children can be strings, markup, other elements or lists/iterators.</p> <p>Elements can be arbitrarily nested:</p> Nested elements<pre><code>&gt;&gt;&gt; from markupy.tag import Article, Section, P\n&gt;&gt;&gt; print(Section[Article[P[\"Lorem ipsum\"]]])\n&lt;section&gt;&lt;article&gt;&lt;p&gt;Lorem ipsum&lt;/p&gt;&lt;/article&gt;&lt;/section&gt;\n</code></pre> <p>Don't forget to close your tags</p> <p>Another main advantage of the markupy syntax over raw HTML is that you don't have to repeat the tag name to close an element. Of course you still need to close your tags with a closing bracket <code>]</code> but this is much more straightforward and your IDE should help you matching/indenting them fairly easily.</p>"},{"location":"usage/#textstrings","title":"Text/Strings","text":"<p>It is possible to pass a string directly as an element's child:</p> Using a string as children<pre><code>&gt;&gt;&gt; from markupy.tag import H1\n&gt;&gt;&gt; print(H1[\"Welcome to my site!\"])\n&lt;h1&gt;Welcome to my site!&lt;/h1&gt;\n</code></pre> <p>Strings are automatically escaped to avoid XSS vulnerabilities. It is convenient and safe to directly insert variable data via f-strings:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import H1\n&gt;&gt;&gt; user_supplied_name = \"bobby &lt;/h1&gt;\"\n&gt;&gt;&gt; print(H1[f\"hello {user_supplied_name}\"])\n&lt;h1&gt;hello bobby &amp;lt;/h1&amp;gt;&lt;/h1&gt;\n</code></pre>"},{"location":"usage/#injecting-markup","title":"Injecting Markup","text":"<p>If you have HTML markup that you want to insert without further escaping, wrap it in <code>Markup</code> from the markupsafe library. markupsafe is a dependency of markupy and is automatically installed:</p> Injecting markup<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; print(Div[Markup(\"&lt;foo&gt;&lt;/foo&gt;\")])\n&lt;div&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/div&gt;\n</code></pre> <p>If you are generate Markdown and want to insert it into an element, use <code>Markup</code>:</p> Injecting generated markdown<pre><code>&gt;&gt;&gt; from markdown import markdown\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div[Markup(markdown('# Hi'))])\n&lt;div&gt;&lt;h1&gt;Hi&lt;/h1&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#conditional-rendering","title":"Conditional Rendering","text":"<p>Children that evaluate to <code>True</code>, <code>False</code> and <code>None</code> will not be rendered. Python's <code>and</code> and <code>or</code> operators will short-circuit. You can use this to conditionally render content with inline <code>and</code> and <code>or</code>.</p> Conditional rendering with a value that may be None<pre><code>&gt;&gt;&gt; from markupy.tag import Div, Strong\n\n# No &lt;strong&gt; tag will be rendered since error is None\n&gt;&gt;&gt; error = None\n&gt;&gt;&gt; print(Div[error and Strong[error]])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; error = \"Email address is invalid.\"\n&gt;&gt;&gt; print(Div[error and Strong[error]])\n&lt;div&gt;&lt;strong&gt;Email address is invalid.&lt;/strong&gt;&lt;/div&gt;\n\n# Inline if/else can also be used:\n&gt;&gt;&gt; print(Div[Strong[error] if error else None])\n&lt;div&gt;&lt;strong&gt;Email address is invalid.&lt;/strong&gt;&lt;/div&gt;\n</code></pre> Conditional rendering based on a bool variable<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n\n&gt;&gt;&gt; is_allowed = True\n&gt;&gt;&gt; print(Div[is_allowed and \"Access granted!\"])\n&lt;div&gt;Access granted!&lt;/div&gt;\n&gt;&gt;&gt; print(Div[is_allowed or \"Access denied!\"])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; is_allowed = False\n&gt;&gt;&gt; print(Div[is_allowed and \"Access granted!\"])\n&lt;div&gt;&lt;/div&gt;\n&gt;&gt;&gt; print(Div[is_allowed or \"Access denied!\"])\n&lt;div&gt;Access denied&lt;/div&gt;\n</code></pre>"},{"location":"usage/#loops-iterating-over-children","title":"Loops / Iterating Over Children","text":"<p>You can pass a list, tuple or generator to generate multiple children:</p> Iterate over a generator<pre><code>&gt;&gt;&gt; from markupy.tag import Ul, Li\n&gt;&gt;&gt; print(Ul[(Li[letter] for letter in \"abc\")])\n&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;\n</code></pre> <p>Note</p> <p>The generator will be lazily evaluated when rendering the element, not directly when the element is constructed.</p> <p>A <code>list</code> can be used similar to a JSX fragment:</p> Render a list of child elements<pre><code>&gt;&gt;&gt; from markupy.tag import Div, Img\n&gt;&gt;&gt; my_images = [Img(src=\"a.jpg\"), Img(src=\"b.jpg\")]\n&gt;&gt;&gt; print(Div[my_images])\n&lt;div&gt;&lt;img src=\"a.jpg\"&gt;&lt;img src=\"b.jpg\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#custom-elements-web-components","title":"Custom Elements / Web Components","text":"<p>Custom elements / web components are HTML elements that contains at least one dash (<code>-</code>). Since <code>-</code> cannot be used in Python identifiers, here's how you'd write them in markupy depending on your favorite syntax:</p> CapitalizedCasesnake_case Custom elements with CapitalizedCase syntax<pre><code>&gt;&gt;&gt; from markupy.tag import MyCustomElement\n&gt;&gt;&gt; print(MyCustomElement['hi!'])\n&lt;my-custom-element&gt;hi!&lt;/my-custom-element&gt;\n</code></pre> Custom elements with snake_case syntax<pre><code>&gt;&gt;&gt; from markupy.tag import my_custom_element\n&gt;&gt;&gt; print(my_custom_element['hi!'])\n&lt;my-custom-element&gt;hi!&lt;/my-custom-element&gt;\n</code></pre>"},{"location":"usage/#html-doctype","title":"HTML Doctype","text":"<p>The HTML5 doctype is automatically prepended to the <code>&lt;html&gt;</code> tag:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Html\n&gt;&gt;&gt; print(Html)\n&lt;!doctype html&gt;&lt;html&gt;&lt;/html&gt;\n</code></pre>"},{"location":"usage/#html-comments","title":"HTML Comments","text":"<p>Since the Python code is the source of the HTML generation, to add a comment to the code, most of the time regular Python comments (<code>#</code>) are used.</p> <p>If you want to emit HTML comments that will be visible in the browser, you need to initialize a new element whose name is made of any number of <code>_</code> (for example, the following would work: <code>_</code>, <code>__</code>, <code>___</code>, etc...):</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Div, _\n&gt;&gt;&gt; print(Div[_[\"This is a HTML comment!\"]])\n&lt;div&gt;&lt;!--This is a HTML comment!--&gt;&lt;/div&gt;\n</code></pre> <p>Given that a comment is a <code>Element</code>, you can wrap other elements as children:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Div, Strong, _\n&gt;&gt;&gt; print(Div[_[\"This is a HTML comment!\", Strong[\"Hidden text\"]]])\n&lt;div&gt;&lt;!--This is a HTML comment!&lt;strong&gt;Hidden text&lt;/strong&gt;--&gt;&lt;/div&gt;\n</code></pre> <p>If you need full control over the exact rendering of the comment, you can create comments or arbitrary text by injecting your own markup. See the Injecting Markup section above for details.</p>"},{"location":"usage/#attributes","title":"Attributes","text":"<p>HTML attributes are defined by calling the element. They can be specified in a couple of different ways.</p>"},{"location":"usage/#elements-without-attributes","title":"Elements Without Attributes","text":"<p>Some elements do not have attributes, they can be specified by just the element itself:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Hr\n&gt;&gt;&gt; print(Hr)\n&lt;hr&gt;\n</code></pre>"},{"location":"usage/#keyword-arguments","title":"Keyword Arguments","text":"<p>Attributes can be specified via keyword arguments:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Img\n&gt;&gt;&gt; print(Img(src=\"picture.jpg\"))\n&lt;img src=\"picture.jpg\"&gt;\n</code></pre> <p>In Python, some names such as <code>class</code> and <code>for</code> are reserved and cannot be used as keyword arguments. Instead, they can be specified as <code>class_</code> or <code>for_</code> when using keyword arguments:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Label\n&gt;&gt;&gt; print(Label(for_=\"myfield\"))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre> <p>Attributes that contains dashes <code>-</code> can be specified using mixedCase syntax:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Form\n&gt;&gt;&gt; print(Form(hxPost=\"/foo\"))\n&lt;form hx-post=\"/foo\"&gt;&lt;/form&gt;\n</code></pre> <p>But what about PEP8 ?!</p> <p>Some might argue that using mixedCase for attribute names is not Pythonic. It is not indeed. It's a tradeoff we are doing given the low number of chars available to build valid identifiers in Python and the broad diversity of possible chars that can be used as HTML attributes. Just keep in mind anyway that the vast majority of HTML attributes are single worded lower case.</p> <p>markupy also allows you to write more complex HTML attributes by using the following conventions:</p> HTML attribute markupy attribute HTML to markupy conversion <code>data-value=\"...\"</code> <code>dataValue=\"...\"</code> <code>kebab-case</code> \u279c <code>mixedCase</code> <code>v-on:click=\"...\"</code> <code>vOn__click=\"...\"</code> colon <code>:</code> \u279c double underscore <code>__</code> <code>@click=\"...\"</code> <code>_click=\"...\"</code> leading at <code>@</code> \u279c leading underscore <code>_</code> <code>@click.outside=\"...\"</code> <code>_click_outside=\"...\"</code> dot <code>.</code> \u279c underscore <code>_</code> <p>Combining all those rules together, you can basically write as python identifiers 95% of HTML attributes used in modern frontend frameworks and libraries such as htmx, Alpine.js or Vue.js</p>"},{"location":"usage/#idclass-selector-shorthand","title":"Id/Class selector shorthand","text":"<p>Defining <code>id</code> and <code>class</code> attributes is common when writing HTML. A string shorthand that looks like a CSS selector can be used to quickly define id and classes:</p> Define id<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div(\"#myid\"))\n&lt;div id=\"myid\"&gt;&lt;/div&gt;\n</code></pre> Define multiple classes<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div(\".foo.bar\"))\n&lt;div class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre> Combining both id and classes<pre><code>&gt;&gt;&gt; from markupy.tag import Div\n&gt;&gt;&gt; print(Div(\"#myid.foo.bar\"))\n&lt;div id=\"myid\" class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre> <p>Selector string format</p> <p>The selector string should begin with the <code>#id</code> if present, then followed by <code>.classes</code> definition.</p>"},{"location":"usage/#attributes-as-dict","title":"Attributes as Dict","text":"<p>Attributes can also be specified as a <code>dict</code>. This is useful when using attributes that are reserved Python keywords (like <code>for</code> or <code>class</code>), when the attribute name contains special characters or when you want to define attributes dynamically.</p> Using Alpine.js with @-syntax (shorthand for x-on)<pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; print(Button({\"@click.shift\": \"addToSelection()\"}))\n&lt;button @click.shift=\"addToSelection()\"&gt;&lt;/button&gt;\n</code></pre> Using an attribute with a reserved keyword<pre><code>&gt;&gt;&gt; from markupy.tag import Label\n&gt;&gt;&gt; print(Label({\"for\": \"myfield\"}))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre>"},{"location":"usage/#booleanempty-attributes","title":"Boolean/Empty Attributes","text":"<p>In HTML, boolean attributes such as <code>disabled</code> are considered \"true\" when they exist. Specifying an attribute as <code>True</code> will make it appear (without a value). <code>False</code> will make it hidden. This is useful and brings the semantics of <code>bool</code> to HTML.</p> True bool attribute<pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; print(Button(disabled=True))\n&lt;button disabled&gt;&lt;/button&gt;\n</code></pre> False bool attribute<pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; print(Button(disabled=False))\n&lt;button&gt;&lt;/button&gt;\n</code></pre>"},{"location":"usage/#conditionally-mixing-css-classes","title":"Conditionally Mixing CSS Classes","text":"<p>To make it easier to mix CSS classes, the <code>class</code> attribute accepts a list of class names or a dict. Falsey values will be ignored.</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; is_primary = True\n&gt;&gt;&gt; print(Button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn btn-primary\"&gt;&lt;/button&gt;\n&gt;&gt;&gt; is_primary = False\n&gt;&gt;&gt; print(Button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn\"&gt;&lt;/button&gt;\n&gt;&gt;&gt;\n</code></pre>"},{"location":"usage/#combining-modes","title":"Combining Modes","text":"<p>Attributes via id/class shorthand, keyword arguments and dictionary can be combined:</p> Specifying attribute via multiple arguments<pre><code>&gt;&gt;&gt; from htyp import label\n&gt;&gt;&gt; print(label(\"#myid.foo.bar\", {'for': \"somefield\"}, name=\"myname\",))\n&lt;label id=\"myid\" class=\"foo bar\" for=\"somefield\" name=\"myname\"&gt;&lt;/label&gt;\n</code></pre> <p>Order is important</p> <p>When combining multiple attribute definition methods, it's important to respect the order between them: first should come the selector id/class string, then dictionary of attributes and finally keyword attributes.</p>"},{"location":"usage/#escaping-of-attributes","title":"Escaping of Attributes","text":"<p>Attributes are always escaped. This makes it possible to pass arbitrary HTML fragments or scripts as attributes. The output may look a bit obfuscated since all unsafe characters are escaped but the browser will interpret it correctly:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Button\n&gt;&gt;&gt; print(Button(id=\"example\", onclick=\"let name = 'bob'; alert('hi' + name);\")[\"Say hi\"])\n&lt;button onclick=\"let name = &amp;#39;bob&amp;#39;; alert(&amp;#39;hi&amp;#39; + name);\"&gt;Say hi&lt;/button&gt;\n</code></pre> <p>In the browser, the parsed attribute as returned by <code>document.getElementById(\"example\").getAttribute(\"onclick\")</code> will be the original string <code>let name = 'bob'; alert('hi' + name);</code>.</p> <p>Escaping will happen whether or not the value is wrapped in <code>markupsafe.Markup</code> or not. This may seem confusing at first but is useful when embedding HTML snippets as attributes:</p> Escaping of Markup<pre><code>&gt;&gt;&gt; from markupy.tag import Ul\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; # This markup may come from another library/template engine\n&gt;&gt;&gt; some_markup = Markup(\"\"\"&lt;li class=\"bar\"&gt;&lt;/li&gt;\"\"\")\n&gt;&gt;&gt; print(Ul(dataTemplate=some_markup))\n&lt;ul data-template=\"&amp;lt;li class=&amp;#34;bar&amp;#34;&amp;gt;&amp;lt;/li&amp;gt;\"&gt;&lt;/ul&gt;\n</code></pre>"},{"location":"usage/#render-elements-without-a-parent-orphans","title":"Render elements without a parent (orphans)","text":"<p>In some cases such as returning partial content it is useful to render elements without a parent element. This is useful in HTMX partial responses.</p> <p>You may use <code>render_node</code> to achieve this:</p> Render elements without a parent<pre><code>&gt;&gt;&gt; from markupy import render_node\n&gt;&gt;&gt; from markupy.tag import Tr\n&gt;&gt;&gt; print(render_node([Tr[\"a\"], Tr[\"b\"]]))\n&lt;tr&gt;a&lt;/tr&gt;&lt;tr&gt;b&lt;/tr&gt;\n</code></pre> <p><code>render_node()</code> accepts all kinds of <code>Node</code> objects. You may use it to render anything that would normally be a chil of another element.</p> <p>Best practice: Only use render_node() to render non-Elements</p> <p>You can render regular elements by using <code>str()</code>, e.g. <code>str(P[\"hi\"])</code>. While <code>render_node()</code> would give the same result, it is more straightforward and better practice to just use <code>str()</code> when rendering a regular element. Only use <code>render_node()</code> when you do not have a parent element.</p>"},{"location":"usage/#iterating-of-the-output","title":"Iterating of the Output","text":"<p>Iterating over a markupy element will yield the resulting contents in chunks as they are rendered:</p> <pre><code>&gt;&gt;&gt; from markupy.tag import Ul, Li\n&gt;&gt;&gt; for chunk in Ul[Li[\"a\"], Li[\"b\"]]:\n...     print(f\"got a chunk: {chunk!r}\")\n...\ngot a chunk: '&lt;ul&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'a'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'b'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;/ul&gt;'\n</code></pre> <p>Just like render_node(), there is <code>iter_node()</code> that can be used when you need to iterate over a list of elements without a parent:</p> <pre><code>&gt;&gt;&gt; from markupy import iter_node\n&gt;&gt;&gt; from markupy.tag import Li\n&gt;&gt;&gt; for chunk in iter_node([Li[\"a\"], Li[\"b\"]]):\n...     print(f\"got a chunk: {chunk!r}\")\n...\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'a'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'b'\ngot a chunk: '&lt;/li&gt;'\n</code></pre>"}]}
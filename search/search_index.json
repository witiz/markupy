{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>markupy is a plain Python alternative to traditional templates engines for generating HTML code.</p> <p>Writing this code in Python with markupy...</p> <pre><code># Import \"elements\" like they were regular Python objects\nfrom markupy.elements import A, Body, Head, Html, Li, P, Title, Ul\n\nmenu = [(\"Home\", \"/\"), (\"About us\", \"/about\"), (\"Contact\", \"/contact\")]\nprint(\n    Html[\n        Head[Title[\"My website\"]],\n        Body[\n            P[\"Table of contents:\"],\n            Ul(\".menu\")[(Li[A(href=url)[title]] for title, url in menu)],\n        ],\n    ]\n)\n</code></pre> <p>...will generate this HTML:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My website&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Table of contents:&lt;/p&gt;\n    &lt;ul class=\"menu\"&gt;\n      &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"/about\"&gt;About us&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"/contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Seems interesting? Try it by yourself with our online html2markupy converter.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Like most Python web developers, we have relied on template engines (Jinja, Django, ...) since forever to generate HTML on the server side. Although this is fine for simple needs, when your site grows bigger, you might start facing some issues:</p> <ul> <li> <p>More an more Python code get put into unreadable and untestable macros</p> </li> <li> <p>Extends and includes make it very hard to track required parameters</p> </li> <li> <p>Templates are very permissive regarding typing making it more error prone</p> </li> </ul> <p>If this is you struggling with templates, then you should definitely give markupy a try!</p>"},{"location":"#inspiration","title":"Inspiration","text":"<p>markupy started as a fork of htpy. Even though the two projects are still conceptually very similar, we started markupy in order to support a slightly different syntax to optimize readability, reduce risk of conflicts with variables, and better support for non native html attributes syntax. On top of that, markupy provides a first class support for class based components.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Leverage static types: Use mypy or pyright to type check your code.</p> </li> <li> <p>Great debugging: Avoid cryptic stack traces from templates. Use your favorite Python debugger.</p> </li> <li> <p>Easy to extend: There is no special way to define template tags/filters. Just call regular functions.</p> </li> <li> <p>Works with existing Python web framework: Works great with Django, Flask or any other Python web framework!</p> </li> <li> <p>Works great with htmx: markupy makes for a great experience when writing server rendered partials/components.</p> </li> <li> <p>Create reusable components: Define components, snippets, complex layouts/pages as regular Python variables or functions.</p> </li> <li> <p>Familiar concepts from React: React helped make it popular writing HTML with a programming language. markupy uses a lot of similar constructs.</p> </li> <li> <p>Customizable: Use or create 3rd party libraries to leverage the power of markupy</p> </li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>markupy generates HTML elements and attributes and provide a few helpers.</p> <p>markupy does not enforce any particular pattern or style to organize your pages, components and layouts. That does not mean that markupy cannot be used to build sophisticated web pages or applications.</p> <p>Rather the opposite: you are encouraged the leverage the power of Python to structure your project. Use modules, classes, functions, decorators, list comprehension, generators, conditionals, static typing and any other feature of Python to organize your components. This gives you a lot of power and makes markupy scale from a small one file project to bigger applications.</p>"},{"location":"#installation","title":"Installation","text":"<p>markupy is available on PyPI. You may install the latest version using pip:</p> <pre><code>pip install markupy\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The full documentation is available at markupy.witiz.com:</p> <ul> <li>Mastering elements</li> <li>Advanced usage</li> <li>Reusability with Fragments and Components</li> <li>Integrating with Django</li> <li>Integrating with Flask</li> <li>Integrating with Starlette</li> <li>html2markupy</li> </ul>"},{"location":"advanced/","title":"Advanced usage","text":""},{"location":"advanced/#loops-and-conditions","title":"Loops and conditions","text":""},{"location":"advanced/#looping-iterating-over-content","title":"Looping / iterating over content","text":"<p>You can pass any iterable such as <code>list</code>, <code>tuple</code> or <code>generator</code> to generate multiple children:</p> Iterate over a generator<pre><code>&gt;&gt;&gt; from markupy.elements import Ul, Li\n&gt;&gt;&gt; print(Ul[(Li[letter] for letter in \"abc\")])\n&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;\n</code></pre> <p>A <code>list</code> can be used similar to a JSX fragment:</p> Render a list of child elements<pre><code>&gt;&gt;&gt; from markupy.elements import Div, Img\n&gt;&gt;&gt; my_images = [Img(src=\"a.jpg\"), Img(src=\"b.jpg\")]\n&gt;&gt;&gt; print(Div[my_images])\n&lt;div&gt;&lt;img src=\"a.jpg\"&gt;&lt;img src=\"b.jpg\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"advanced/#conditional-rendering","title":"Conditional rendering","text":"<p>Children that evaluate to <code>True</code>, <code>False</code> and <code>None</code> will not be rendered. Python's <code>and</code> and <code>or</code> operators will short-circuit. You can use this to conditionally render content with inline <code>and</code> and <code>or</code>.</p> Conditional rendering with a value that may be None<pre><code>&gt;&gt;&gt; from markupy.elements import Div, Strong\n\n# No &lt;strong&gt; tag will be rendered since error is None\n&gt;&gt;&gt; error = None\n&gt;&gt;&gt; print(Div[error and Strong[error]])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; error = \"Email address is invalid.\"\n&gt;&gt;&gt; print(Div[error and Strong[error]])\n&lt;div&gt;&lt;strong&gt;Email address is invalid.&lt;/strong&gt;&lt;/div&gt;\n\n# Inline if/else can also be used:\n&gt;&gt;&gt; print(Div[Strong[error] if error else None])\n&lt;div&gt;&lt;strong&gt;Email address is invalid.&lt;/strong&gt;&lt;/div&gt;\n</code></pre> Conditional rendering based on a bool variable<pre><code>&gt;&gt;&gt; from markupy.elements import Div\n\n&gt;&gt;&gt; is_allowed = True\n&gt;&gt;&gt; print(Div[is_allowed and \"Access granted!\"])\n&lt;div&gt;Access granted!&lt;/div&gt;\n&gt;&gt;&gt; print(Div[is_allowed or \"Access denied!\"])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; is_allowed = False\n&gt;&gt;&gt; print(Div[is_allowed and \"Access granted!\"])\n&lt;div&gt;&lt;/div&gt;\n&gt;&gt;&gt; print(Div[is_allowed or \"Access denied!\"])\n&lt;div&gt;Access denied&lt;/div&gt;\n</code></pre>"},{"location":"advanced/#string-escaping","title":"String escaping","text":""},{"location":"advanced/#element-content-escaping","title":"Element content escaping","text":"<p>Element contents are automatically escaped to avoid XSS vulnerabilities.</p> String escaping in action<pre><code>&gt;&gt;&gt; from markupy.elements import H1\n&gt;&gt;&gt; user_supplied_name = \"l33t &lt;/h1&gt;\"\n&gt;&gt;&gt; print(H1[f\"hello {user_supplied_name}\"])\n&lt;h1&gt;hello l33t &amp;lt;/h1&amp;gt;&lt;/h1&gt;\n</code></pre> <p>An exception for <code>script</code> and <code>style</code> tags</p> <p>Script and style tags are special because they usually expect their content to be respectively javascript and css code. In order for code to work properly, <code>Script</code> and <code>Style</code> child nodes will not be automatically escaped. Keep in mind that you will need to escape sensitive values yourself inside these 2 tags. </p> <p>If you have HTML markup that you want to insert without further escaping, wrap it in <code>Markup</code> from the markupsafe library. markupsafe is a dependency of markupy and is automatically installed:</p> Injecting markup<pre><code>&gt;&gt;&gt; from markupy.elements import Div\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; print(Div[Markup(\"&lt;foo&gt;&lt;/foo&gt;\")])\n&lt;div&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/div&gt;\n</code></pre> <p>If you are generating Markdown and want to insert it into an element, use <code>Markup</code>:</p> Injecting generated markdown<pre><code>&gt;&gt;&gt; from markdown import markdown\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; from markupy.elements import Div\n&gt;&gt;&gt; print(Div[Markup(markdown('# Hi'))])\n&lt;div&gt;&lt;h1&gt;Hi&lt;/h1&gt;&lt;/div&gt;\n</code></pre>"},{"location":"advanced/#element-attributes-escaping","title":"Element attributes escaping","text":"<p>Attributes are always escaped. This makes it possible to pass arbitrary HTML fragments or scripts as attributes. The output may look a bit obfuscated since all unsafe characters are escaped but the browser will interpret it correctly:</p> <pre><code>&gt;&gt;&gt; from markupy.elements import Button\n&gt;&gt;&gt; print(Button(id=\"example\", onclick=\"let name = 'bob'; alert('hi' + name);\")[\"Say hi\"])\n&lt;button onclick=\"let name = &amp;#39;bob&amp;#39;; alert(&amp;#39;hi&amp;#39; + name);\"&gt;Say hi&lt;/button&gt;\n</code></pre> <p>In the browser, the parsed attribute as returned by <code>document.getElementById(\"example\").getAttribute(\"onclick\")</code> will be the original string <code>let name = 'bob'; alert('hi' + name);</code>.</p> <p>Escaping will happen whether or not the value is wrapped in <code>markupsafe.Markup</code> or not. This may seem confusing at first but is useful when embedding HTML snippets as attributes:</p> Escaping of Markup<pre><code>&gt;&gt;&gt; from markupy.elements import Ul\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; # This markup may come from another library/template engine\n&gt;&gt;&gt; some_markup = Markup(\"\"\"&lt;li class=\"bar\"&gt;&lt;/li&gt;\"\"\")\n&gt;&gt;&gt; print(Ul(dataTemplate=some_markup))\n&lt;ul data-template=\"&amp;lt;li class=&amp;#34;bar&amp;#34;&amp;gt;&amp;lt;/li&amp;gt;\"&gt;&lt;/ul&gt;\n</code></pre>"},{"location":"advanced/#special-elements","title":"Special elements","text":""},{"location":"advanced/#custom-elements-web-components","title":"Custom elements / Web components","text":"<p>Custom elements / web components are HTML elements that contains at least one dash (<code>-</code>). Since <code>-</code> cannot be used in Python identifiers, here's how you'd write them in markupy:</p> Custom elements with CapitalizedCase syntax<pre><code>&gt;&gt;&gt; from markupy.elements import MyCustomElement\n&gt;&gt;&gt; print(MyCustomElement['hi!'])\n&lt;my-custom-element&gt;hi!&lt;/my-custom-element&gt;\n</code></pre>"},{"location":"advanced/#html-doctype","title":"HTML doctype","text":"<p>The HTML5 doctype is automatically prepended to the <code>&lt;html&gt;</code> tag:</p> <pre><code>&gt;&gt;&gt; from markupy.elements import Html\n&gt;&gt;&gt; print(Html)\n&lt;!doctype html&gt;&lt;html&gt;&lt;/html&gt;\n</code></pre>"},{"location":"advanced/#html-comments","title":"HTML comments","text":"<p>Since the Python code is the source of the HTML generation, to add a comment to the code, most of the time regular Python comments (<code>#</code>) are used.</p> <p>If you want to emit HTML comments that will be visible in the browser, you need to initialize a special element whose name is <code>_</code>:</p> <pre><code>&gt;&gt;&gt; from markupy.elements import Div, _\n&gt;&gt;&gt; print(Div[_[\"This is a HTML comment\"]])\n&lt;div&gt;&lt;!--This is a HTML comment--&gt;&lt;/div&gt;\n</code></pre> <p>Given that a comment is a <code>Element</code>, you can wrap other elements as children:</p> <pre><code>&gt;&gt;&gt; from markupy.elements import Div, Strong, _\n&gt;&gt;&gt; print(Div[_[\"This is a HTML comment\", Strong[\"Hidden text\"]]])\n&lt;div&gt;&lt;!--This is a HTML comment&lt;strong&gt;Hidden text&lt;/strong&gt;--&gt;&lt;/div&gt;\n</code></pre>"},{"location":"advanced/#advanced-attributes","title":"Advanced attributes","text":""},{"location":"advanced/#boolean-attributes","title":"Boolean attributes","text":"<p>In HTML, boolean attributes such as <code>disabled</code> are considered \"true\" when they exist. Specifying an attribute as <code>True</code> will make it appear (without a value). <code>False</code> will make it hidden. This is useful and brings the semantics of <code>bool</code> to HTML.</p> True bool attribute<pre><code>&gt;&gt;&gt; from markupy.elements import Button\n&gt;&gt;&gt; print(Button(disabled=True))\n&lt;button disabled&gt;&lt;/button&gt;\n</code></pre> False bool attribute<pre><code>&gt;&gt;&gt; from markupy.elements import Button\n&gt;&gt;&gt; print(Button(disabled=False))\n&lt;button&gt;&lt;/button&gt;\n</code></pre>"},{"location":"advanced/#3rd-party-object-attributes-libraries","title":"3rd party object attributes libraries","text":"<p>The <code>markupy.attributes</code> provides a complete list of HTML5 attributes. In addition, markupy is exposing all the required APIs for 3rd party libraries to implement object attributes specific to any framework or library. If you are interested in developping your own <code>markupy</code> addons, you might be interested in \"Attribute Handlers\".</p> <p>We will list here any package we might be aware of.</p> <ul> <li>markupy_htmx: Provides convenient Python methods to build HTMX attributes</li> </ul>"},{"location":"advanced/#attribute-handlers","title":"Attribute Handlers","text":"<p>Attribute Handlers are a powerful way to extend behaviour of attributes. Most users will not benefit from using them directly, but it can be useful in some cases or for library maintainers.</p> <p>An attribute handler is a user-defined function that gets called every time an attribute is set on an element. This allows to intercept changes and modify the attribute on the fly if needed before it is persisted.</p> <p>Let's show a concrete example. Let's say you want all boolean attributes value to be toggled from True to False and vice versa (don't do that for real, your users might be really upset at you).</p> <p>We'll start by implementing an attribute handler for that. It's a function that you can name howerver you like, although you must respect its signature (parameters and return types):</p> <pre><code>from markupy import Attribute\n\ndef liar_attribute_handler(old: Attribute | None, new: Attribute) -&gt; Attribute | None:\n    if isinstance(new.value, bool):\n        # here, we toggle the attribute value if it's a boolean\n        new.value = not new.value\n        # do not \"return new\" to let other potential handlers do their job\n    return None\n</code></pre> <p>Let's detail the parameters and return value of an handler:</p> <ul> <li><code>old</code>: the previous/current instance of the attribute. It can be <code>None</code> if the attribute has not been set previously for a given <code>Element</code>. Otherwise, it will be an instance of <code>Attribute</code>, a very lightweight object with only 2 properties: <code>name</code> and <code>value</code>.</li> <li><code>new</code>: the instance of the <code>Attribute</code> that is about to be updated. Its <code>value</code> property is mutable so you can update it in place.</li> <li>return type depends on what to do next:<ul> <li>returning <code>None</code> tells <code>markupy</code> to continue processing other registered handlers before persisting. Handlers are processed in the reverse order of registration (most recent first).</li> <li>returning an instance of <code>Attribute</code> instructs <code>markupy</code> to either:<ul> <li>stop processing handlers and persist immediately the returned instance if <code>new</code> is returned</li> <li>restart a handlers chain processing if a new instance of <code>Attribute(name, value)</code> is returned</li> </ul> </li> </ul> </li> </ul> <p>Now that our handler is defined, we need to register it. This can be done in 2 different ways:</p> Usage of attribute_handlers.register() method<pre><code>from markupy import attribute_handlers\n\nattribute_handlers.register(liar_attribute_handler)\n</code></pre> Usage of @attribute_handlers.register decorator<pre><code>from markupy import Attribute, attribute_handlers\n\n@attribute_handlers.register\ndef liar_attribute_handler(old: Attribute | None, new: Attribute) -&gt; Attribute | None:\n    ...\n</code></pre> <p>And that's it. Now we can try to assign boolean attributes to any element and see what happens:</p> <pre><code>from markupy import elements as el\n\nprint(el.Input(disabled=True)) # &lt;input&gt;\nprint(el.Input(disabled=False)) # &lt;input disabled&gt;\n</code></pre>"},{"location":"advanced/#streaming-iterating-of-the-output","title":"Streaming / Iterating of the Output","text":"<p>Iterating over a markupy element will yield the resulting contents in chunks as they are rendered:</p> <pre><code>&gt;&gt;&gt; from markupy.elements import Ul, Li\n&gt;&gt;&gt; for chunk in Ul[Li[\"a\"], Li[\"b\"]]:\n...     print(f\"got a chunk: {chunk!r}\")\n...\ngot a chunk: '&lt;ul&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'a'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'b'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;/ul&gt;'\n</code></pre> <p>Note</p> <p>This feature can be leveraged to stream HTML contents by returning a generator instead of a fully generated str. How to integrate this is heavily depending on which framework you are using to power your website.</p>"},{"location":"django/","title":"Integrating with Django","text":""},{"location":"django/#returning-a-markupy-response","title":"Returning a markupy Response","text":"<p>markupy elements can be passed directly to <code>HttpResponse</code>:</p> views.py<pre><code>from django.http import HttpResponse\nfrom markupy.elements import H1\n\ndef my_view(request):\n    return HttpResponse(H1[\"Hi Django!\"])\n</code></pre>"},{"location":"django/#using-markupy-as-part-of-an-existing-django-template","title":"Using markupy as part of an existing Django template","text":"<p>markupy elements are marked as \"safe\" and can be injected directly into Django templates. This can be useful if you want to start using markupy gradually in an existing template based Django project:</p> base.html<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;My Django Site&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        {{ content }}\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> views.py<pre><code>from django.shortcuts import render\n\nfrom markupy.elements import H1\n\n\ndef index(request):\n    return render(request, \"base.html\", {\n        \"content\": H1[\"Welcome to my site!\"],\n    })\n</code></pre>"},{"location":"django/#render-a-django-form","title":"Render a Django Form","text":"<p>CSRF token, form widgets and errors can be directly used within markupy elements:</p> forms.py<pre><code>from django import forms\n\n\nclass MyForm(forms.Form):\n    name = forms.CharField()\n</code></pre> views.py<pre><code>from django.http import HttpRequest, HttpResponse\n\nfrom .components import my_form_page, my_form_success_page\nfrom .forms import MyForm\n\n\ndef my_form(request: HttpRequest) -&gt; HttpResponse:\n    form = MyForm(request.POST or None)\n    if form.is_valid():\n        return HttpResponse(my_form_success_page())\n\n    return HttpResponse(my_form_page(request, my_form=form))\n</code></pre> components.py<pre><code>from django.http import HttpRequest\nfrom django.template.backends.utils import csrf_input\n\nfrom markupy import View\nfrom markupy.elements import Body, Button, Form, H1, Head, Html, Title\n\nfrom .forms import MyForm\n\n\ndef base_page(title: str, content: View) -&gt; View:\n    return Html[\n        Head[Title[title]],\n        Body[content],\n    ]\n\n\ndef my_form_page(request: HttpRequest, *, form: MyForm) -&gt; View:\n    return base_page(\n        \"My form\",\n        form(method=\"post\")[\n            csrf_input(request),\n            form.errors,\n            form[\"name\"],\n            Button[\"Submit!\"],\n        ],\n    )\n\n\ndef my_form_success_page() -&gt; View:\n    return base_page(\n        \"Success!\",\n        H1[\"Success! The form was valid!\"],\n    )\n</code></pre>"},{"location":"django/#implement-custom-form-widgets-with-markupy","title":"Implement Custom Form Widgets With markupy","text":"<p>You can implement a custom form widget directly with markupy like this:</p> widgets.py<pre><code>from django.forms import widgets\n\nfrom markupy.elements import SlInput\n\n\nclass ShoelaceInput(widgets.Widget):\n    \"\"\"\n    A form widget using Shoelace's &lt;sl-input&gt; element.\n    More info: https://shoelace.style/components/input\n    \"\"\"\n\n    def render(self, name, value, attrs=None, renderer=None):\n        return str(SlInput(attrs, name=name, value=value))\n</code></pre>"},{"location":"elements/","title":"Mastering elements","text":""},{"location":"elements/#importing-elements","title":"Importing elements","text":"<p>HTML elements are imported directly from the <code>markupy.elements</code> module as their name using the CapitalizedCase syntax. Although HTML elements are usually spelled in lower case, using CapitalizedCase in markupy avoids naming conflicts with your own variables and makes it easier to distinguish markupy tags vs other parts of your code.</p> Importing elements<pre><code>&gt;&gt;&gt; from markupy.elements import Div\n&gt;&gt;&gt; print(Div)\n&lt;div&gt;&lt;/div&gt;\n</code></pre> <p>You can import elements individually as shown above, or you can use an alias to dynamically invoke elements as you need them:</p> Importing elements with alias<pre><code>&gt;&gt;&gt; from markupy.elements as el\n&gt;&gt;&gt; print(el.Div)\n&lt;div&gt;&lt;/div&gt;\n&gt;&gt;&gt; print(el.Input)\n&lt;input&gt;\n</code></pre>"},{"location":"elements/#element-content","title":"Element content","text":"<p>Content of elements is specified using square brackets <code>[]</code> syntax on an element. Let's take our example from above and specify content for our <code>div</code>:</p> Div content<pre><code>&gt;&gt;&gt; from markupy.elements import Div\n&gt;&gt;&gt; print(Div[\"Hello World!\"])\n&lt;div&gt;Hello World!&lt;/div&gt;\n</code></pre> <p>Content can be strings, ints, lists, other elements, etc... Basically, whatever can be iterated and/or stringified is a valid content. And you are not limited to just one child, can be as meny as you want:</p> Nested elements<pre><code>&gt;&gt;&gt; from markupy.elements import Div, H1\n&gt;&gt;&gt; print(Div[H1[\"Lorem ipsum\"], \"Hello World!\"])\n&lt;div&gt;&lt;h1&gt;Lorem ipsum&lt;/h1&gt;Hello World!&lt;/div&gt;\n</code></pre> <p>Don't forget to close your tags</p> <p>Another main advantage of the markupy syntax over raw HTML is that you don't have to repeat the tag name to close an element. Of course you still need to close your tags with a closing bracket <code>]</code> but this is much more straightforward and your IDE should help you matching/indenting them fairly easily.</p>"},{"location":"elements/#element-attributes","title":"Element attributes","text":"<p>HTML attributes are specified by using parenthesis <code>()</code> syntax on an element.</p> Element attributes<pre><code>&gt;&gt;&gt; from markupy.elements import Div\n&gt;&gt;&gt; print(Div(id=\"container\", style=\"color:red\"))\n&lt;div id=\"container\" style=\"color:red\"&gt;&lt;/div&gt;\n</code></pre> <p>They can be specified in different ways.</p>"},{"location":"elements/#elements-without-attributes","title":"Elements without attributes","text":"<p>For elements that you do not want attributes, they can be specified by just the element itself:</p> <pre><code>&gt;&gt;&gt; from markupy.elements import Hr\n&gt;&gt;&gt; print(Hr)\n&lt;hr&gt;\n</code></pre>"},{"location":"elements/#keyword-attributes","title":"Keyword attributes","text":"<p>Attributes can be specified via keyword arguments, also known as kwargs:</p> <pre><code>&gt;&gt;&gt; from markupy.elements import Img\n&gt;&gt;&gt; print(Img(src=\"picture.jpg\"))\n&lt;img src=\"picture.jpg\"&gt;\n</code></pre> <p>In Python, some names such as <code>class</code> and <code>for</code> are reserved and cannot be used as keyword arguments. Instead, they can be specified as <code>class_</code> or <code>for_</code> when using keyword arguments:</p> <pre><code>&gt;&gt;&gt; from markupy.elements import Label\n&gt;&gt;&gt; print(Label(for_=\"myfield\"))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre> <p>Attributes that contains dashes <code>-</code> can be specified by using underscores:</p> <pre><code>&gt;&gt;&gt; from markupy.elements import Form\n&gt;&gt;&gt; print(Form(hx_post=\"/foo\"))\n&lt;form hx-post=\"/foo\"&gt;&lt;/form&gt;\n</code></pre>"},{"location":"elements/#selector-string-shorthand-for-id-and-class","title":"Selector string shorthand for id and class","text":"<p>Defining <code>id</code> and <code>class</code> attributes is common when writing HTML. A string shorthand that looks like a CSS selector can be used to quickly define id and classes:</p> Define id<pre><code>&gt;&gt;&gt; from markupy.elements import Div\n&gt;&gt;&gt; print(Div(\"#myid\"))\n&lt;div id=\"myid\"&gt;&lt;/div&gt;\n</code></pre> Define multiple classes<pre><code>&gt;&gt;&gt; from markupy.elements import Div\n&gt;&gt;&gt; print(Div(\".foo.bar\"))\n&lt;div class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre> Combining both id and classes<pre><code>&gt;&gt;&gt; from markupy.elements import Div\n&gt;&gt;&gt; print(Div(\"#myid.foo.bar\"))\n&lt;div id=\"myid\" class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre> <p>Selector string format</p> <p>The selector string should begin with the <code>#id</code> if present, then followed by <code>.classes</code> definition.</p>"},{"location":"elements/#dict-attributes","title":"Dict attributes","text":"<p>Attributes can also be specified as a <code>dict</code>. This is useful when using attributes that are reserved Python keywords (like <code>for</code> or <code>class</code>), when the attribute name contains special characters or when you want to define attributes dynamically.</p> Using Alpine.js with @-syntax (shorthand for x-on)<pre><code>&gt;&gt;&gt; from markupy.elements import Button\n&gt;&gt;&gt; print(Button({\"@click.shift\": \"addToSelection()\"}))\n&lt;button @click.shift=\"addToSelection()\"&gt;&lt;/button&gt;\n</code></pre> Using an attribute with a reserved keyword<pre><code>&gt;&gt;&gt; from markupy.elements import Label\n&gt;&gt;&gt; print(Label({\"for\": \"myfield\"}))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre>"},{"location":"elements/#object-attributes","title":"Object attributes","text":"<p>Finally there is one last way to define attributes and it is very powerful, it is called \"object attributes\", athough it's very transparent as a user since you're only ever calling functions that build those objects for you.</p> Using object attributes<pre><code>&gt;&gt;&gt; from markupy import attributes as at\n&gt;&gt;&gt; from markupy.elements import Input\n&gt;&gt;&gt; print(Input(at.id(\"myid\"), at.tabindex(3), at.disabled(True)))\n&lt;input id=\"myid\" tabindex=\"3\" disabled&gt;\n</code></pre> <p>There are multiple benefits of defining attributes this way:</p> <ul> <li>Suggestion: your IDE will suggest what attributes you can use</li> <li>Type hinting: attributes all have their own type (<code>disabled</code> is <code>bool</code>, <code>maxlength</code> is <code>int</code>, etc...)</li> <li>Autocompletion: for attributes that take pre-definied set of values, you will be able to autocomplete them, avoiding the risk of forgetting or mistyping the correct values</li> <li>Helper functions for some attributes like <code>class_()</code> that can take multiple input types (<code>str</code>, <code>list</code>, <code>dict</code>) for commodity</li> </ul> <p>Finally, custom object attributes can be defined in several ways:</p> <ul> <li>If attribute is a valid python identifier, just do <code>at.foo_bar(\"baz\")</code></li> <li>Otherwise, you can pass any arbitrary string by constructing an attribute object and pass it a name and a value: <code>Attribute(\"@foo:bar\", \"baz\")</code></li> </ul>"},{"location":"elements/#combining-different-types-of-attributes","title":"Combining different types of attributes","text":"<p>Attributes via id/class selector shorthand, dictionary, object and keyword attributes can be combined and used simultaneously:</p> Specifying attribute via multiple arguments<pre><code>&gt;&gt;&gt; from markupy import attributes as attr\n&gt;&gt;&gt; from markupy.elements import Label\n&gt;&gt;&gt; print(Label(\"#myid.foo.bar\", {\"for\": \"somefield\"}, at.tabindex(-1), name=\"myname\"))\n&lt;label id=\"myid\" class=\"foo bar\" for=\"somefield\" tabindex=\"-1\" name=\"myname\"&gt;&lt;/label&gt;\n</code></pre> <p>Order is important</p> <p>When combining multiple attribute definition methods, it's important to respect the order between them:</p> <ol> <li>selector id/class string (optional, at most one)</li> <li>dictionary attributes (optional, at most one)</li> <li>object attributes (optional, unlimited)</li> <li>keyword attributes (optional, unlimited)</li> </ol>"},{"location":"flask/","title":"Integrating with Flask","text":""},{"location":"flask/#basic-integration","title":"Basic integration","text":"<p>Rendering markupy elements or components in flask is as easy as return a stringified instance from your routes.</p> <pre><code>from flask import Flask\nfrom markupy import Component, View\nfrom markupy.elements import H1\n\napp = Flask(__name__)\n\n@app.route(\"/page\")\ndef page():\n    return str(H1[\"Page with element\"])\n\nclass MyComponent(Component):\n    def render(self) -&gt; View:\n        return H1[\"Page with component\"]\n\n@app.route(\"/component\")\ndef component():\n    return str(MyComponent())\n</code></pre>"},{"location":"flask/#avoid-casting-to-str-by-subclassing-flask","title":"Avoid casting to str by subclassing Flask","text":"<p>As you saw previously, since Flask doesn't know about our elements or components, we need to convert them to <code>str</code> before returning them.</p> <p>You can avoid that by subclassing <code>Flask</code> and overriding the <code>make_response</code> method:</p> <pre><code>from flask import Flask\nfrom markupy import View\n\nclass MarkupyFlask(Flask):\n    # Here we override make_response to be able to return View instances\n    # from our routes directly without having to cast them to str()\n    def make_response(self, rv):\n        if isinstance(rv, View):\n            rv = str(rv)\n        return super().make_response(rv)\n</code></pre> <p>Note</p> <p>Here we check if our object to be rendered is a subclass of <code>markupy.View</code>, which is the base class for all markupy <code>Element</code>, <code>Fragment</code> and <code>Component</code>.</p> <p>And then our previous example becomes like this (basically we instantiate MarkupyFlask instead of Flask previously and do not need the calls to <code>str</code> anymore):</p> <pre><code>from my_flask import MarkupyFlask\nfrom markupy import Component, View\nfrom markupy.elements import H1\n\napp = MarkupyFlask(__name__)\n\n@app.route(\"/page\")\ndef page():\n    return H1[\"Hello!\"]\n\nclass MyComponent(Component):\n    def render(self) -&gt; View:\n        return H1[\"Hello!\"]\n\n@app.route(\"/component\")\ndef component():\n    return MyComponent()\n</code></pre>"},{"location":"flask/#streaming-html","title":"Streaming HTML","text":"<p>Given that markupy elements and components are iterables, you can leverage the power of python generators to stream the response instead of sending it all at once.</p> <p>Flask supports streaming out of the box (see docs).</p> <p>Note</p> <p>The examples below are returning very small and simple content, please be aware that you will only benefit from streaming for large contents.</p>"},{"location":"flask/#streaming-by-returning-a-generator","title":"Streaming by returning a generator","text":"<pre><code>from flask import Flask\nfrom markupy import Component, View\nfrom markupy.elements import H1\n\napp = Flask(__name__)\n\n@app.route(\"/page\")\ndef page():\n    return iter(H1[\"Streaming element\"])\n\nclass MyComponent(Component):\n    def render(self) -&gt; View:\n        return H1[\"Streaming component\"]\n\n@app.route(\"/component\")\ndef component():\n    return iter(MyComponent())\n</code></pre>"},{"location":"flask/#streaming-by-subclassing-flask","title":"Streaming by subclassing Flask","text":"<p>Same as above, if you prefer a cleaner syntax that will apply streaming to all your routes, we can adapt our <code>Flask</code> subclass:</p> <pre><code>from flask import Flask\nfrom markupy import View\n\nclass MarkupyStreamFlask(Flask):\n    # Here we override make_response to be able to stream View instances\n    # from our routes directly when returning them\n    def make_response(self, rv):\n        if isinstance(rv, View):\n            rv = iter(rv)\n        return super().make_response(rv)\n</code></pre> <p>And then in your routes:</p> <pre><code>@app.route(\"/page\")\ndef page():\n    return H1[\"Hello!\"]\n</code></pre>"},{"location":"html2markupy/","title":"Converting HTML to markupy","text":"<p>Maybe you already have a bunch of HTML, or templates that you would like to migrate to markupy. We got you covered in multiple ways.</p>"},{"location":"html2markupy/#converting-online-with-the-html2markupy-website","title":"Converting online with the html2markupy website","text":"<p>The simplest way to experiment with markupy and convert your HTML snippets is to use the online html2markupy converter.</p> <p>The app is powered by markupy itself so you will get the exact same result as the one provided by the below method.</p>"},{"location":"html2markupy/#converting-locally-with-the-built-in-html2markupy-command","title":"Converting locally with the built-in html2markupy command","text":"<p>The utility command <code>html2markupy</code> ships with <code>markupy</code>, and can be used to transform existing html into Python code (markupy!).</p> <pre><code>$ html2markupy -h\nusage: html2markupy [-h] [--selector | --no-selector] [--dict-attrs | --no-dict-attrs] [--el-prefix | --no-el-prefix] [input]\n\npositional arguments:\n  input                 input HTML from file or stdin\n\noptions:\n  -h, --help            show this help message and exit\n  --selector, --no-selector\n                        Use the selector #id.class syntax instead of explicit `id` and `class_` attributes (default: True)\n  --dict-attrs, --no-dict-attrs\n                        Prefer dict attributes (default: False)\n  --el-prefix, --no-el-prefix\n                        Output mode for imports of markupy elements (default: False)\n</code></pre> <p>Lets say you have an existing HTML file:</p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;title&gt;html2markupy&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;h1 class=\"heading\"&gt;Welcome to html2markupy!&lt;/h1&gt;\n    &lt;/header&gt;\n    &lt;main id=\"container\"&gt;\n        Discover a powerful way to build your HTML pages and components in Python!\n    &lt;/main&gt;\n    &lt;footer&gt;\n        Powered by &lt;a href=\"https://markupy.witiz.com\"&gt;markupy&lt;/a&gt;\n    &lt;/footer&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now, if you run the command, it outputs the corresponding Python code (markupy).</p> <pre><code>$ html2markupy index.html\n</code></pre> <pre><code>from markupy.elements import A,Body,Footer,H1,Head,Header,Html,Main,Title\nHtml(lang=\"en\")[Head[Title[\"html2markupy\"]],Body[Header[H1(\".heading\")[\"Welcome to html2markupy!\"]],Main(\"#container\")[\"Discover a powerful way to build your HTML pages and components in Python!\"],Footer[\"Powered by\",A(href=\"https://markupy.witiz.com\")[\"markupy\"]]]]\n</code></pre>"},{"location":"html2markupy/#piping-inputstdin-stream","title":"Piping Input/Stdin Stream","text":"<p>You can also pipe input to markupy:</p> <pre><code>$ cat index.html | html2markupy\n</code></pre> <p>This can be combined with other workflows in the way that you find most suitable. For example, you might pipe from your clipboard to markupy, and optionally direct the output to a file.</p>"},{"location":"html2markupy/#formatting-the-output","title":"Formatting the Output","text":"<p><code>html2markupy</code> is by default providing an unformatted output, but you can easily combine it with your preferred formatter (must be installed separately). Below is an example formatting with ruff:</p> <pre><code>$ html2markupy index.html | ruff format - \n</code></pre>"},{"location":"html2markupy/#command-options","title":"Command Options","text":"<p>Say you have the following HTML snippet.</p> example.html<pre><code>&lt;section id=\"main-section\" class=\"container\"&gt;\n  &lt;a class=\"btn btn-primary\" href=\"/index\"&gt;Home&lt;/a&gt;\n&lt;/section&gt;\n</code></pre> <p>You can adapt the markupy conversion with a couple of options.</p>"},{"location":"html2markupy/#imports-management","title":"Imports management","text":"<p>Some people prefer to <code>from markupy import elements as el</code> instead of importing individual elements <code>from markupy.elements</code>. If this is you, you can use the <code>--el-prefix</code> option to get corresponding output when using <code>html2markupy</code>.</p> --no-el-prefix (default)--el-prefix <pre><code>from markupy.elements import A, Section\n\nSection(\"#main-section.container\")[\n    A(\".btn.btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre> <pre><code>from markupy import elements as el\n\nel.Section(\"#main-section.container\")[\n    el.A(\".btn.btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre>"},{"location":"html2markupy/#explicit-id-and-class-kwargs","title":"Explicit <code>id</code> and <code>class</code> kwargs","text":"<p>If you prefer the explicit <code>id=\"id\", class_=\"class\"</code> kwargs syntax over the default markupy shorthand <code>#id.class</code> syntax, you can get it by passing the <code>--no-selector</code> flag.</p> --selector (default)--no-selector <pre><code>from markupy.elements import A, Section\n\nSection(\"#main-section.container\")[\n    A(\".btn.btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre> <pre><code>from markupy.elements import A, Section\n\nSection(id=\"main-section\" class_=\"container\")[\n    A(class_=\"btn btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre>"},{"location":"html2markupy/#attributes-as-dict-vs-arguments","title":"Attributes as dict vs arguments","text":"<p>The <code>--dict-args</code> flag lets you declare attributes as a dictionary instead of the default python arguments.</p> --no-dict-args (default)--dict-args <pre><code>from markupy.elements import A, Section\n\nSection(\"#main-section.container\")[\n    A(\".btn.btn-primary\", href=\"/index\")[\"Home\"]\n]\n</code></pre> <pre><code>from markupy.elements import A, Section\n\nSection(\"#main-section.container\")[\n    A(\".btn.btn-primary\", {\"href\": \"/index\"})[\"Home\"]\n]\n</code></pre>"},{"location":"reusability/","title":"Reusability with Fragments and Components","text":""},{"location":"reusability/#fragments","title":"Fragments","text":"<p>Fragments allow you to wrap a group of nodes (not necessarily elements) so that they can be rendered without a wrapping element.</p> <pre><code>&gt;&gt;&gt; from markupy.elements import P, I, Fragment\n&gt;&gt;&gt; content = Fragment[\"Hello \", None, I[\"world!\"]]\n&gt;&gt;&gt; print(content)\nHello &lt;i&gt;world!&lt;/i&gt;\n\n&gt;&gt;&gt; print(P[content])\n&lt;p&gt;Hello &lt;i&gt;world!&lt;/i&gt;&lt;/p&gt;\n</code></pre>"},{"location":"reusability/#components","title":"Components","text":"<p>Although markupy intend to remain a generic library to allow you generate HTML, it also provides a powerful support for components in order to build reusable chunks of HTML.</p>"},{"location":"reusability/#building-your-first-component","title":"Building your first component","text":"<p>Let's start by creating a component that renders a Boostrap card.</p>"},{"location":"reusability/#components-as-functions","title":"Components as functions","text":"<p>Building a function component is a simple as returning elements from a regular python function:</p> <pre><code>def card_component(title:str, content:str) -&gt; View:\n    return Div(\".card\")[\n        Div(\".card-body\")[\n            H5(\".card-title\")[\n                title\n            ],\n            P(\".card-text\")[\n                content\n            ],\n        ]\n    ]\n</code></pre> <p>Note</p> <p>In the rest of the documentation, we will mostly focus on class based components that offer more flexibility with the ability to inherit each other but after all, it's also a matter of taste so feel free to experiment and find what works best for you.</p>"},{"location":"reusability/#components-as-classes","title":"Components as classes","text":"<p>Building a class component is done by subclassing the built-in <code>Component</code> abstract class and implementing the one required <code>render()</code> instance method that defines your component structure.</p> <pre><code>from markupy import Component, View\nfrom markupy.elements import Div, H5, P\n\nclass CardComponent(Component):\n    def render(self) -&gt; View:\n        return Div(\".card\")[\n            Div(\".card-body\")[\n                H5(\".card-title\")[\n                    \"Card title\"\n                ],\n                P(\".card-text\")[\n                    \"This is my card's content.\"\n                ],\n            ]\n        ]\n</code></pre> <p>And then to generate the actual HTML for this component, you just need to instantiate it and make it into a <code>str</code>:</p> <pre><code>&gt;&gt;&gt; str(CardComponent())\n</code></pre> <p>Note that the component <code>render()</code> method needs to return a <code>View</code>, which means it can be any of an <code>Element</code>, <code>Fragment</code> or another <code>Component</code>.</p> <p>See how this can save you from repeating a lot of code? But we're not there yet, because right now our card always has the same title and content. Time to keep improving our component.</p>"},{"location":"reusability/#pass-data-to-a-class-component-with-constructor","title":"Pass data to a class component with constructor","text":"<p>Let's make our card data dynamic by adding a constructor to our component. Let's say our card is in charge of displaying a <code>Post</code> object:</p> <pre><code>from markupy import Component, View\nfrom markupy.elements import Div, H5, P\nfrom my_models import Post\n\nclass PostCardComponent(Component):\n    def __init__(self, *, post: Post) -&gt; None:\n        super().__init__()\n        self.post = post\n\n    def render(self) -&gt; View:\n        return Div(\".card\")[\n            Div(\".card-body\")[\n                H5(\".card-title\")[\n                    self.post.title\n                ],\n                P(\".card-text\")[\n                    self.post.description\n                ],\n            ]\n        ]\n</code></pre>"},{"location":"reusability/#components-in-components","title":"Components in components","text":"<p>Usually, cards are displayed as part of a collection. Let's say we have a blog that is managing a list of posts, let's create a new component that would be in charge of displaying a list of cards:</p> <pre><code>from markupy import Component, View\nfrom markupy.elements import Div, H5, P\nfrom my_models import Post\n\nclass PostCardListComponent(Component):\n    def __init__(self, *, posts: list[Post]) -&gt; None:\n        super().__init__()\n        self.posts = posts\n\n    def render(self) -&gt; View:\n        return Div(\".card-group\")[\n            (PostCardComponent(post=post) for post in self.posts)\n        ]\n</code></pre> <p>And that's it, we are looping over a list of posts to generate card components that are added as children of another component. Displaying a list of posts as cards is now super easy:</p> <pre><code>&gt;&gt;&gt; print(PostCardListComponent(posts=my_posts))\n</code></pre>"},{"location":"reusability/#passing-children-to-components","title":"Passing children to components","text":"<p>Content can be assigned to component the same way we are doing for Fragments or Elements. To tell your component where such content needs to be injected when rendering, you need to call the <code>self.render_content()</code> reserved method:</p> <pre><code>from markupy import elements as el\nfrom markupy import Component, View\n\nclass Title(Component):\n    def __init__(self, id: str) -&gt; None:\n        super().__init__()\n        self.id = id\n\n    def render(self) -&gt; View:\n        return el.H1(\".title.header\", id=self.id)[self.render_content()]\n</code></pre> <p>Then to use this component:</p> <pre><code>&gt;&gt;&gt; print(Title(id=\"headline\")[\"hello \", el.I(\".star.icon\")])\n</code></pre> <p>This will render as:</p> <pre><code>&lt;h1 class=\"title header\" id=\"headline\"&gt;\n    hello &lt;i class=\"star icon\"&gt;&lt;/i&gt;\n&lt;/h1&gt;\n</code></pre>"},{"location":"reusability/#dataclasses-components","title":"Dataclasses components","text":"<p>Components can also be defined as <code>dataclass</code>, which allows for a more compact syntax. Here's for example what the component above would look like with <code>@dataclass</code>:</p> <pre><code>from dataclasses import dataclass\nfrom markupy import elements as el\nfrom markupy import Component, View\n\n@dataclass\nclass Title(Component):\n    id: str\n\n    def render(self) -&gt; View:\n        return el.H1(\".title.header\", id=self.id)[self.render_content()]\n</code></pre>"},{"location":"reusability/#using-components-to-define-layouts","title":"Using components to define layouts","text":"<p>Another very interesting use for components is to define your pages layouts.</p>"},{"location":"reusability/#implementing-a-basic-layout","title":"Implementing a basic layout","text":"<p>Below is a very basic layout that specifies a default head and body, with some placeholders that we can implement when inheriting this layout.</p> <pre><code>from markupy import Component, View\nfrom markupy.elements import H1, Body, Footer, Head, Header, Html, Main, Title\n\nclass BaseLayout(Component):\n    def render_title(self) -&gt; str:\n        return \"My website\"\n\n    def render_main(self) -&gt; View:\n        return None\n\n    def render(self) -&gt; View:\n        return Html[\n            Head[\n                Title[self.render_title()],\n            ],\n            Body[\n                Header(\".container\")[H1[\"Welcome!\"]],\n                Main(\".container\")[self.render_main()],\n                Footer(\".container\")[\"\u00a9 My Company\"],\n            ],\n        ]\n</code></pre> <p>Note</p> <p>Here we defined the placeholders as instance methods called render_*. This is just a convention and nothing is enforced in naming them.</p>"},{"location":"reusability/#extending-a-layout-to-implement-a-page","title":"Extending a layout to implement a page","text":"<p>Then when we need to define a specific page, we need to subclass the layout an override the needed placeholders:</p> <pre><code>from markupy import Fragment, View\nfrom markupy.elements import H2\nfrom my_components import PostCardListComponent\nfrom my_models import Post\n\nclass BlogPage(BaseLayout):\n    def __init__(self, *, posts:list[Post]) -&gt; None:\n        super().__init__()\n        self.posts = posts\n\n    def render_title(self) -&gt; str:\n        return f\"Blog | {super().render_title()}\"\n\n    def render_main(self) -&gt; View:\n        return Fragment[\n            H2[\"Blog posts\"],\n            PostCardListComponent(posts=self.posts)\n        ]\n</code></pre> <p>Note</p> <p>Notice in the <code>render_title</code> how we can only partially replace the content from the inherited layout (here we are preprending the default page title with the <code>Blog |</code> value.)</p> <p>As usual, generating HTML for the page is just a matter of instanciating and converting to <code>str</code>:</p> <pre><code>&gt;&gt;&gt; str(BlogPage(posts=my_posts))\n</code></pre>"},{"location":"starlette/","title":"Integrating with Starlette","text":"<p>markupy can be used with Starlette to generate HTML. Since FastAPI is built upon Starlette, markupy can also be used with FastAPI.</p> <p>To return HTML contents, pass a markupy element to Starlette's <code>HTMLResponse</code>:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse\nfrom starlette.routing import Route\n\nfrom markupy.elements import H1, Body, Html\n\n\nasync def index(request: Request) -&gt; HTMLResponse:\n    return HTMLResponse(Html[Body[H1[\"Hi Starlette!\"]]])\n\n\n# Run it with `uv run uvicorn html_response:app``\napp = Starlette(\n    routes=[Route(\"/\", index)],\n)\n</code></pre>"}]}